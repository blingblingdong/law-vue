{
  "version": 3,
  "sources": ["../../vue3-resize/src/utils/compatibility.js", "../../vue3-resize/src/package/ResizeObserver/ResizeObserver.vue", "../../vue3-resize/src/package/ResizeObserver/ResizeObserver.vue", "../../vue3-resize/src/package/ResizeObserver/index.js", "../../vue3-resize/src/index.js", "../../vue3-virtual-scroller/src/config.js", "../../vue3-virtual-scroller/node_modules/vue3-observe-visibility2/dist/vue3-observe-visibility2.esm.js", "../../vue3-virtual-scroller/src/components/common.js", "../../vue3-virtual-scroller/src/utils.js", "../../vue3-virtual-scroller/src/components/RecycleScroller.vue", "../../vue3-virtual-scroller/src/components/RecycleScroller.vue", "../../vue3-virtual-scroller/src/components/DynamicScroller.vue", "../../vue3-virtual-scroller/src/components/DynamicScroller.vue", "../../vue3-virtual-scroller/src/components/DynamicScrollerItem.js", "../../vue3-virtual-scroller/src/index.js"],
  "sourcesContent": ["export function getInternetExplorerVersion () {\n  const ua = window.navigator.userAgent\n\n  const msie = ua.indexOf('MSIE ')\n  if (msie > 0) {\n    // IE 10 or older => return version number\n    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10)\n  }\n\n  const trident = ua.indexOf('Trident/')\n  if (trident > 0) {\n    // IE 11 => return version number\n    const rv = ua.indexOf('rv:')\n    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10)\n  }\n\n  const edge = ua.indexOf('Edge/')\n  if (edge > 0) {\n    // Edge (IE 12+) => return version number\n    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10)\n  }\n\n  // other browser\n  return -1\n}\n", "<template>\n  <div\n    ref=\"elRef\"\n    class=\"vue3-resize-observer\"\n    tabindex=\"-1\"\n  />\n</template>\n\n<script>\nimport { onMounted, ref, onBeforeUnmount } from 'vue'\nimport { getInternetExplorerVersion } from '../../utils/compatibility'\n\nlet isIE\n\nfunction initCompat () {\n  if (!initCompat.init) {\n    initCompat.init = true\n    isIE = getInternetExplorerVersion() !== -1\n  }\n}\n\nexport default {\n  name: 'ResizeObserver',\n\n  props: {\n    showTrigger: {\n      type: Boolean,\n      default: false,\n    },\n  },\n\n  emits: ['notify'],\n\n  setup (props, { emit }) {\n    let _w = 0\n    let _h = 0\n    const elRef = ref(null)\n    let _resizeObject = null\n\n    const compareAndNotify = () => {\n      if (_w !== elRef.value.offsetWidth || _h !== elRef.value.offsetHeight) {\n        _w = elRef.value.offsetWidth\n        _h = elRef.value.offsetHeight\n\n        emit('notify', {\n          width: _w,\n          height: _h,\n        })\n      }\n    }\n\n    const addResizeHandlers = () => {\n      _resizeObject.contentDocument.defaultView.addEventListener('resize', compareAndNotify)\n      compareAndNotify()\n    }\n\n    const removeResizeHandlers = () => {\n      if (_resizeObject && _resizeObject.onload) {\n        if (!isIE && _resizeObject.contentDocument) {\n          _resizeObject.contentDocument.defaultView.removeEventListener('resize', compareAndNotify)\n        }\n\n        elRef.value.removeChild(_resizeObject)\n\n        _resizeObject.onload = null\n        _resizeObject = null\n      }\n    }\n\n    onMounted(() => {\n      initCompat()\n\n      _w = elRef.value.offsetWidth\n      _h = elRef.value.offsetHeight\n\n      const object = document.createElement('object')\n      _resizeObject = object\n\n      object.setAttribute('aria-hidden', 'true')\n      object.setAttribute('tabindex', '-1')\n      object.onload = addResizeHandlers\n      object.type = 'text/html'\n\n      if (isIE) {\n        elRef.value.appendChild(object)\n      }\n\n      object.data = 'about:blank'\n\n      if (!isIE) {\n        elRef.value.appendChild(object)\n      }\n\n      if (props.showTrigger) {\n        compareAndNotify()\n      }\n    })\n\n    onBeforeUnmount(() => {\n      removeResizeHandlers()\n    })\n\n    return { elRef }\n  },\n}\n</script>\n\n<style>\n.vue3-resize-observer {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: -1;\n  width: 100%;\n  height: 100%;\n  border: none;\n  background-color: transparent;\n  pointer-events: none;\n  display: block;\n  overflow: hidden;\n  opacity: 0;\n}\n\n.vue3-resize-observer object {\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n  pointer-events: none;\n  z-index: -1;\n}\n</style>\n", "<template>\n  <div\n    ref=\"elRef\"\n    class=\"vue3-resize-observer\"\n    tabindex=\"-1\"\n  />\n</template>\n\n<script>\nimport { onMounted, ref, onBeforeUnmount } from 'vue'\nimport { getInternetExplorerVersion } from '../../utils/compatibility'\n\nlet isIE\n\nfunction initCompat () {\n  if (!initCompat.init) {\n    initCompat.init = true\n    isIE = getInternetExplorerVersion() !== -1\n  }\n}\n\nexport default {\n  name: 'ResizeObserver',\n\n  props: {\n    showTrigger: {\n      type: Boolean,\n      default: false,\n    },\n  },\n\n  emits: ['notify'],\n\n  setup (props, { emit }) {\n    let _w = 0\n    let _h = 0\n    const elRef = ref(null)\n    let _resizeObject = null\n\n    const compareAndNotify = () => {\n      if (_w !== elRef.value.offsetWidth || _h !== elRef.value.offsetHeight) {\n        _w = elRef.value.offsetWidth\n        _h = elRef.value.offsetHeight\n\n        emit('notify', {\n          width: _w,\n          height: _h,\n        })\n      }\n    }\n\n    const addResizeHandlers = () => {\n      _resizeObject.contentDocument.defaultView.addEventListener('resize', compareAndNotify)\n      compareAndNotify()\n    }\n\n    const removeResizeHandlers = () => {\n      if (_resizeObject && _resizeObject.onload) {\n        if (!isIE && _resizeObject.contentDocument) {\n          _resizeObject.contentDocument.defaultView.removeEventListener('resize', compareAndNotify)\n        }\n\n        elRef.value.removeChild(_resizeObject)\n\n        _resizeObject.onload = null\n        _resizeObject = null\n      }\n    }\n\n    onMounted(() => {\n      initCompat()\n\n      _w = elRef.value.offsetWidth\n      _h = elRef.value.offsetHeight\n\n      const object = document.createElement('object')\n      _resizeObject = object\n\n      object.setAttribute('aria-hidden', 'true')\n      object.setAttribute('tabindex', '-1')\n      object.onload = addResizeHandlers\n      object.type = 'text/html'\n\n      if (isIE) {\n        elRef.value.appendChild(object)\n      }\n\n      object.data = 'about:blank'\n\n      if (!isIE) {\n        elRef.value.appendChild(object)\n      }\n\n      if (props.showTrigger) {\n        compareAndNotify()\n      }\n    })\n\n    onBeforeUnmount(() => {\n      removeResizeHandlers()\n    })\n\n    return { elRef }\n  },\n}\n</script>\n\n<style>\n.vue3-resize-observer {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: -1;\n  width: 100%;\n  height: 100%;\n  border: none;\n  background-color: transparent;\n  pointer-events: none;\n  display: block;\n  overflow: hidden;\n  opacity: 0;\n}\n\n.vue3-resize-observer object {\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n  pointer-events: none;\n  z-index: -1;\n}\n</style>\n", "import ResizeObserver from './ResizeObserver'\n\nResizeObserver.install = function (app) {\n  app.component(ResizeObserver.name, ResizeObserver)\n}\n\nexport default ResizeObserver\n", "import ResizeObserver from './package/ResizeObserver'\nimport { version } from '../package.json'\n\n// Install the components\nconst install = (app) => {\n  app.use(ResizeObserver)\n}\n\n// Plugin\nconst Vue3Resize = {\n  version,\n  install,\n}\n\nexport {\n  ResizeObserver,\n  install,\n}\n\nexport default Vue3Resize\n", "export default {\r\n  itemsLimit: 1000,\r\n}\r\n", "function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction processOptions(value) {\n  var options;\n\n  if (typeof value === 'function') {\n    // Simple options (callback-only)\n    options = {\n      callback: value\n    };\n  } else {\n    // Options object\n    options = value;\n  }\n\n  return options;\n}\nfunction throttle(callback, delay) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var timeout;\n  var lastState;\n  var currentArgs;\n\n  var throttled = function throttled(state) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    currentArgs = args;\n    if (timeout && state === lastState) return;\n    var leading = options.leading;\n\n    if (typeof leading === 'function') {\n      leading = leading(state, lastState);\n    }\n\n    if ((!timeout || state !== lastState) && leading) {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n    }\n\n    lastState = state;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n      timeout = 0;\n    }, delay);\n  };\n\n  throttled._clear = function () {\n    clearTimeout(timeout);\n    timeout = null;\n  };\n\n  return throttled;\n}\nfunction deepEqual(val1, val2) {\n  if (val1 === val2) return true;\n\n  if (_typeof(val1) === 'object') {\n    // eslint-disable-next-line no-restricted-syntax\n    for (var key in val1) {\n      if (!deepEqual(val1[key], val2[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar VisibilityState =\n/*#__PURE__*/\nfunction () {\n  function VisibilityState(el, options, vnode) {\n    _classCallCheck(this, VisibilityState);\n\n    this.el = el;\n    this.observer = null;\n    this.frozen = false;\n    this.createObserver(options, vnode);\n  }\n\n  _createClass(VisibilityState, [{\n    key: \"createObserver\",\n    value: function createObserver(options) {\n      var _this = this;\n\n      if (this.observer) {\n        this.destroyObserver();\n      }\n\n      if (this.frozen) return;\n      this.options = processOptions(options);\n\n      this.callback = function (result, entry) {\n        _this.options.callback(result, entry);\n\n        if (result && _this.options.once) {\n          _this.frozen = true;\n\n          _this.destroyObserver();\n        }\n      }; // Throttle\n\n\n      if (this.callback && this.options.throttle) {\n        var _ref = this.options.throttleOptions || {},\n            _leading = _ref.leading;\n\n        this.callback = throttle(this.callback, this.options.throttle, {\n          leading: function leading(state) {\n            return _leading === 'both' || _leading === 'visible' && state || _leading === 'hidden' && !state;\n          }\n        });\n      }\n\n      this.oldResult = undefined;\n      this.observer = new IntersectionObserver(function (entries) {\n        var entry = entries[0];\n\n        if (entries.length > 1) {\n          var intersectingEntry = entries.find(function (e) {\n            return e.isIntersecting;\n          });\n\n          if (intersectingEntry) {\n            entry = intersectingEntry;\n          }\n        }\n\n        if (_this.callback) {\n          // Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.\n          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;\n          if (result === _this.oldResult) return;\n          _this.oldResult = result;\n\n          _this.callback(result, entry);\n        }\n      }, this.options.intersection); // Wait for the element to be in document\n\n      setTimeout(function () {\n        if (_this.observer) {\n          _this.observer.observe(_this.el);\n        }\n      });\n    }\n  }, {\n    key: \"destroyObserver\",\n    value: function destroyObserver() {\n      if (this.observer) {\n        this.observer.disconnect();\n        this.observer = null;\n      } // Cancel throttled call\n\n\n      if (this.callback && this.callback._clear) {\n        this.callback._clear();\n\n        this.callback = null;\n      }\n    }\n  }, {\n    key: \"threshold\",\n    get: function get() {\n      return this.options.intersection && this.options.intersection.threshold || 0;\n    }\n  }]);\n\n  return VisibilityState;\n}();\n\nfunction mounted(el, _ref2, vnode) {\n  var value = _ref2.value;\n  if (!value) return;\n\n  if (typeof IntersectionObserver === 'undefined') {\n    console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');\n  } else {\n    var state = new VisibilityState(el, value, vnode);\n    el._vue_visibilityState = state;\n  }\n}\n\nfunction unmounted(el) {\n  var state = el._vue_visibilityState;\n\n  if (state) {\n    state.destroyObserver();\n    delete el._vue_visibilityState;\n  }\n}\n\nfunction componentUpdated(el, _ref3, vnode) {\n  var value = _ref3.value,\n      oldValue = _ref3.oldValue;\n  if (deepEqual(value, oldValue)) return;\n  var state = el._vue_visibilityState;\n\n  if (!value) {\n    unmounted(el);\n    return;\n  }\n\n  if (state) {\n    state.createObserver(value, vnode);\n  } else {\n    mounted(el, {\n      value: value\n    }, vnode);\n  }\n}\n\nvar ObserveVisibility = {\n  mounted: mounted,\n  componentUpdated: componentUpdated,\n  unmounted: unmounted\n};\n\nvar version = \"0.0.3\";\n\nvar install = function install(app) {\n  app.use({\n    // eslint-disable-next-line no-shadow\n    install: function install(app) {\n      app.directive('observe-visibility', ObserveVisibility);\n    }\n  });\n}; // Plugin\n\n\nvar plugin = {\n  version: version,\n  install: install\n};\n\nexport default plugin;\nexport { ObserveVisibility, install };\n", "export const props = {\r\n  items: {\r\n    type: Array,\r\n    required: true,\r\n  },\r\n\r\n  keyField: {\r\n    type: String,\r\n    default: 'id',\r\n  },\r\n\r\n  direction: {\r\n    type: String,\r\n    default: 'vertical',\r\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\r\n  },\r\n}\r\n\r\nexport const scrollParent = (node) => {\r\n  const regex = /(auto|scroll)/;\r\n\r\n  function parents (node, ps) {\r\n    if (node.parentNode === null) { return ps; }\r\n    return parents(node.parentNode, ps.concat([node]));\r\n  }\r\n\r\n  function style (node, prop) {\r\n    return getComputedStyle(node, null).getPropertyValue(prop);\r\n  }\r\n\r\n  function overflow (node) {\r\n    return style(node, \"overflow\") + style(node, \"overflow-y\") + style(node, \"overflow-x\");\r\n  }\r\n\r\n  function scroll (node) {\r\n    return regex.test(overflow(node));\r\n  }\r\n\r\n  function scrollParent (node) {\r\n    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\r\n      return ;\r\n    }\r\n\r\n    const ps = parents(node.parentNode, []);\r\n\r\n    for (let i = 0; i < ps.length; i += 1) {\r\n      if (scroll(ps[i])) {\r\n        return ps[i];\r\n      }\r\n    }\r\n\r\n    return document.scrollingElement || document.documentElement;\r\n  }\r\n\r\n  return scrollParent(node);\r\n}\r\n\r\nexport function simpleArray () {\r\n  return this.items.length && typeof this.items[0] !== 'object'\r\n}\r\n", "export let supportsPassive = false\r\n\r\nif (typeof window !== 'undefined') {\r\n  supportsPassive = false\r\n  try {\r\n    var opts = Object.defineProperty({}, 'passive', {\r\n      get () {\r\n        supportsPassive = true\r\n      },\r\n    })\r\n    window.addEventListener('test', null, opts)\r\n  } catch (e) {}\r\n}\r\n", "<template>\r\n  <div\r\n    v-observe-visibility=\"handleVisibilityChange\"\r\n    class=\"vue-recycle-scroller\"\r\n    :class=\"{\r\n      ready,\r\n      'page-mode': pageMode,\r\n      [`direction-${direction}`]: true,\r\n    }\"\r\n    @scroll.passive=\"handleScroll\"\r\n  >\r\n    <div\r\n      v-if=\"$slots.before\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"before\"\r\n      />\r\n    </div>\r\n\r\n    <div\r\n      ref=\"wrapper\"\r\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\r\n      class=\"vue-recycle-scroller__item-wrapper\"\r\n    >\r\n      <div\r\n        v-for=\"view of pool\"\r\n        :key=\"view.nr.id\"\r\n        :style=\"ready ? { transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px)` } : null\"\r\n        class=\"vue-recycle-scroller__item-view\"\r\n        :class=\"{ hover: hoverKey === view.nr.key }\"\r\n        @mouseenter=\"hoverKey = view.nr.key\"\r\n        @mouseleave=\"hoverKey = null\"\r\n      >\r\n        <slot\r\n          :item=\"view.item\"\r\n          :index=\"view.nr.index\"\r\n          :active=\"view.nr.used\"\r\n        />\r\n      </div>\r\n    </div>\r\n\r\n    <div\r\n      v-if=\"$slots.after\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"after\"\r\n      />\r\n    </div>\r\n\r\n    <ResizeObserver @notify=\"handleResize\" />\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { ResizeObserver } from 'vue3-resize'\r\nimport { ObserveVisibility } from 'vue3-observe-visibility2'\r\nimport config from '../config'\r\nimport { props, simpleArray, scrollParent } from './common'\r\nimport {supportsPassive} from '../utils'\r\nimport {defineComponent} from 'vue'\r\n\r\nlet uid = 0\r\n\r\nexport default defineComponent({\r\n  name: 'RecycleScroller',\r\n\r\n  components: {\r\n    ResizeObserver,\r\n  },\r\n\r\n  directives: {\r\n    ObserveVisibility,\r\n  },\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    itemSize: {\r\n      type: Number,\r\n      default: null,\r\n    },\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      default: null,\r\n    },\r\n\r\n    sizeField: {\r\n      type: String,\r\n      default: 'size',\r\n    },\r\n\r\n    typeField: {\r\n      type: String,\r\n      default: 'type',\r\n    },\r\n\r\n    buffer: {\r\n      type: Number,\r\n      default: 200,\r\n    },\r\n\r\n    pageMode: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    prerender: {\r\n      type: Number,\r\n      default: 0,\r\n    },\r\n\r\n    emitUpdate: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n  },\r\n\r\n  emits: ['visible', 'hidden', 'resize', 'update'],\r\n\r\n  data () {\r\n    return {\r\n      pool: [],\r\n      totalSize: 0,\r\n      ready: false,\r\n      hoverKey: null,\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    sizes () {\r\n      if (this.itemSize === null) {\r\n        const sizes = {\r\n          '-1': { accumulator: 0 },\r\n        }\r\n        const items = this.items\r\n        const field = this.sizeField\r\n        const minItemSize = this.minItemSize\r\n        let computedMinSize = 10000\r\n        let accumulator = 0\r\n        let current\r\n        for (let i = 0, l = items.length; i < l; i++) {\r\n          current = items[i][field] || minItemSize\r\n          if (current < computedMinSize) {\r\n            computedMinSize = current\r\n          }\r\n          accumulator += current\r\n          sizes[i] = { accumulator, size: current }\r\n        }\r\n        // eslint-disable-next-line\r\n        this.$_computedMinItemSize = computedMinSize\r\n        return sizes\r\n      }\r\n      return []\r\n    },\r\n\r\n    simpleArray,\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.updateVisibleItems(true)\r\n    },\r\n\r\n    pageMode () {\r\n      this.applyPageMode()\r\n      this.updateVisibleItems(false)\r\n    },\r\n\r\n    sizes: {\r\n      handler () {\r\n        this.updateVisibleItems(false)\r\n      },\r\n      deep: true,\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_startIndex = 0\r\n    this.$_endIndex = 0\r\n    this.$_views = new Map()\r\n    this.$_unusedViews = new Map()\r\n    this.$_scrollDirty = false\r\n    this.$_lastUpdateScrollPosition = 0\r\n\r\n    // In SSR mode, we also prerender the same number of item for the first render\r\n    // to avoir mismatch between server and client templates\r\n    if (this.prerender) {\r\n      this.$_prerender = true\r\n      this.updateVisibleItems(false)\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    this.applyPageMode()\r\n    this.$nextTick(() => {\r\n      // In SSR mode, render the real number of visible items\r\n      this.$_prerender = false\r\n      this.updateVisibleItems(true)\r\n      this.ready = true\r\n    })\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.removeListeners()\r\n  },\r\n\r\n  methods: {\r\n    addView (pool, index, item, key, type) {\r\n      const view = {\r\n        item,\r\n        position: 0,\r\n      }\r\n      view.nr = {\r\n        id: uid++,\r\n        index,\r\n        used: true,\r\n        key,\r\n        type,\r\n      }\r\n      pool.push(view)\r\n      return view\r\n    },\r\n\r\n    unuseView (view, fake = false) {\r\n      const unusedViews = this.$_unusedViews\r\n      const type = view.nr.type\r\n      let unusedPool = unusedViews.get(type)\r\n      if (!unusedPool) {\r\n        unusedPool = []\r\n        unusedViews.set(type, unusedPool)\r\n      }\r\n      unusedPool.push(view)\r\n      if (!fake) {\r\n        view.nr.used = false\r\n        view.position = -9999\r\n        this.$_views.delete(view.nr.key)\r\n      }\r\n    },\r\n\r\n    handleResize () {\r\n      this.$emit('resize')\r\n      if (this.ready) this.updateVisibleItems(false)\r\n    },\r\n\r\n    handleScroll (event) {\r\n      if (!this.$_scrollDirty) {\r\n        this.$_scrollDirty = true\r\n        requestAnimationFrame(() => {\r\n          this.$_scrollDirty = false\r\n          const { continuous } = this.updateVisibleItems(false, true)\r\n\r\n          // It seems sometimes chrome doesn't fire scroll event :/\r\n          // When non continous scrolling is ending, we force a refresh\r\n          if (!continuous) {\r\n            clearTimeout(this.$_refreshTimout)\r\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100)\r\n          }\r\n        })\r\n      }\r\n    },\r\n\r\n    handleVisibilityChange (isVisible, entry) {\r\n      if (this.ready) {\r\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\r\n          this.$emit('visible')\r\n          requestAnimationFrame(() => {\r\n            this.updateVisibleItems(false)\r\n          })\r\n        } else {\r\n          this.$emit('hidden')\r\n        }\r\n      }\r\n    },\r\n\r\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\r\n      const itemSize = this.itemSize\r\n      const minItemSize = this.$_computedMinItemSize\r\n      const typeField = this.typeField\r\n      const keyField = this.simpleArray ? null : this.keyField\r\n      const items = this.items\r\n      const count = items.length\r\n      const sizes = this.sizes\r\n      const views = this.$_views\r\n      const unusedViews = this.$_unusedViews\r\n      const pool = this.pool\r\n      let startIndex, endIndex\r\n      let totalSize\r\n\r\n      if (!count) {\r\n        startIndex = endIndex = totalSize = 0\r\n      } else if (this.$_prerender) {\r\n        startIndex = 0\r\n        endIndex = this.prerender\r\n        totalSize = null\r\n      } else {\r\n        const scroll = this.getScroll()\r\n\r\n        // Skip update if use hasn't scrolled enough\r\n        if (checkPositionDiff) {\r\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\r\n          if (positionDiff < 0) positionDiff = -positionDiff\r\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\r\n            return {\r\n              continuous: true,\r\n            }\r\n          }\r\n        }\r\n        this.$_lastUpdateScrollPosition = scroll.start\r\n\r\n        const buffer = this.buffer\r\n        scroll.start -= buffer\r\n        scroll.end += buffer\r\n\r\n        // Variable size mode\r\n        if (itemSize === null) {\r\n          let h\r\n          let a = 0\r\n          let b = count - 1\r\n          let i = ~~(count / 2)\r\n          let oldI\r\n\r\n          // Searching for startIndex\r\n          do {\r\n            oldI = i\r\n            h = sizes[i].accumulator\r\n            if (h < scroll.start) {\r\n              a = i\r\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\r\n              b = i\r\n            }\r\n            i = ~~((a + b) / 2)\r\n          } while (i !== oldI)\r\n          i < 0 && (i = 0)\r\n          startIndex = i\r\n\r\n          // For container style\r\n          totalSize = sizes[count - 1].accumulator\r\n\r\n          // Searching for endIndex\r\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\r\n          if (endIndex === -1) {\r\n            endIndex = items.length - 1\r\n          } else {\r\n            endIndex++\r\n            // Bounds\r\n            endIndex > count && (endIndex = count)\r\n          }\r\n        } else {\r\n          // Fixed size mode\r\n          startIndex = ~~(scroll.start / itemSize)\r\n          endIndex = Math.ceil(scroll.end / itemSize)\r\n\r\n          // Bounds\r\n          startIndex < 0 && (startIndex = 0)\r\n          endIndex > count && (endIndex = count)\r\n\r\n          totalSize = count * itemSize\r\n        }\r\n      }\r\n\r\n      if (endIndex - startIndex > config.itemsLimit) {\r\n        this.itemsLimitError()\r\n      }\r\n\r\n      this.totalSize = totalSize\r\n\r\n      let view\r\n\r\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\r\n\r\n      if (this.$_continuous !== continuous) {\r\n        if (continuous) {\r\n          views.clear()\r\n          unusedViews.clear()\r\n          for (let i = 0, l = pool.length; i < l; i++) {\r\n            view = pool[i]\r\n            this.unuseView(view)\r\n          }\r\n        }\r\n        this.$_continuous = continuous\r\n      } else if (continuous) {\r\n        for (let i = 0, l = pool.length; i < l; i++) {\r\n          view = pool[i]\r\n          if (view.nr.used) {\r\n            // Update view item index\r\n            if (checkItem) {\r\n              view.nr.index = items.findIndex(\r\n                item => keyField ? item[keyField] === view.item[keyField] : item === view.item,\r\n              )\r\n            }\r\n\r\n            // Check if index is still in visible range\r\n            if (\r\n              view.nr.index === -1 ||\r\n              view.nr.index < startIndex ||\r\n              view.nr.index >= endIndex\r\n            ) {\r\n              this.unuseView(view)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const unusedIndex = continuous ? null : new Map()\r\n\r\n      let item, type, unusedPool\r\n      let v\r\n      for (let i = startIndex; i < endIndex; i++) {\r\n        item = items[i]\r\n        const key = keyField ? item[keyField] : item\r\n        if (key == null) {\r\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\r\n        }\r\n        view = views.get(key)\r\n\r\n        if (!itemSize && !sizes[i].size) {\r\n          if (view) this.unuseView(view)\r\n          continue\r\n        }\r\n\r\n        // No view assigned to item\r\n        if (!view) {\r\n          type = item[typeField]\r\n          unusedPool = unusedViews.get(type)\r\n\r\n          if (continuous) {\r\n            // Reuse existing view\r\n            if (unusedPool && unusedPool.length) {\r\n              view = unusedPool.pop()\r\n              view.item = item\r\n              view.nr.used = true\r\n              view.nr.index = i\r\n              view.nr.key = key\r\n              view.nr.type = type\r\n            } else {\r\n              view = this.addView(pool, i, item, key, type)\r\n            }\r\n          } else {\r\n            // Use existing view\r\n            // We don't care if they are already used\r\n            // because we are not in continous scrolling\r\n            v = unusedIndex.get(type) || 0\r\n\r\n            if (!unusedPool || v >= unusedPool.length) {\r\n              view = this.addView(pool, i, item, key, type)\r\n              this.unuseView(view, true)\r\n              unusedPool = unusedViews.get(type)\r\n            }\r\n\r\n            view = unusedPool[v]\r\n            view.item = item\r\n            view.nr.used = true\r\n            view.nr.index = i\r\n            view.nr.key = key\r\n            view.nr.type = type\r\n            unusedIndex.set(type, v + 1)\r\n            v++\r\n          }\r\n          views.set(key, view)\r\n        } else {\r\n          view.nr.used = true\r\n          view.item = item\r\n        }\r\n\r\n        // Update position\r\n        if (itemSize === null) {\r\n          view.position = sizes[i - 1].accumulator\r\n        } else {\r\n          view.position = i * itemSize\r\n        }\r\n      }\r\n\r\n      this.$_startIndex = startIndex\r\n      this.$_endIndex = endIndex\r\n\r\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex)\r\n\r\n      // After the user has finished scrolling\r\n      // Sort views so text selection is correct\r\n      clearTimeout(this.$_sortTimer)\r\n      this.$_sortTimer = setTimeout(this.sortViews, 300)\r\n\r\n      return {\r\n        continuous,\r\n      }\r\n    },\r\n\r\n    getListenerTarget () {\r\n      let target = scrollParent(this.$el)\r\n      // Fix global scroll target for Chrome and Safari\r\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\r\n        target = window\r\n      }\r\n      return target\r\n    },\r\n\r\n    getScroll () {\r\n      const { $el: el, direction } = this\r\n      const isVertical = direction === 'vertical'\r\n      let scrollState\r\n\r\n      if (this.pageMode) {\r\n        const bounds = el.getBoundingClientRect()\r\n        const boundsSize = isVertical ? bounds.height : bounds.width\r\n        let start = -(isVertical ? bounds.top : bounds.left)\r\n        let size = isVertical ? window.innerHeight : window.innerWidth\r\n        if (start < 0) {\r\n          size += start\r\n          start = 0\r\n        }\r\n        if (start + size > boundsSize) {\r\n          size = boundsSize - start\r\n        }\r\n        scrollState = {\r\n          start,\r\n          end: start + size,\r\n        }\r\n      } else if (isVertical) {\r\n        scrollState = {\r\n          start: el.scrollTop,\r\n          end: el.scrollTop + el.clientHeight,\r\n        }\r\n      } else {\r\n        scrollState = {\r\n          start: el.scrollLeft,\r\n          end: el.scrollLeft + el.clientWidth,\r\n        }\r\n      }\r\n\r\n      return scrollState\r\n    },\r\n\r\n    applyPageMode () {\r\n      if (this.pageMode) {\r\n        this.addListeners()\r\n      } else {\r\n        this.removeListeners()\r\n      }\r\n    },\r\n\r\n    addListeners () {\r\n      this.listenerTarget = this.getListenerTarget()\r\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive ? {\r\n        passive: true,\r\n      } : false)\r\n      this.listenerTarget.addEventListener('resize', this.handleResize)\r\n    },\r\n\r\n    removeListeners () {\r\n      if (!this.listenerTarget) {\r\n        return\r\n      }\r\n\r\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\r\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\r\n\r\n      this.listenerTarget = null\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      let scroll\r\n      if (this.itemSize === null) {\r\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\r\n      } else {\r\n        scroll = index * this.itemSize\r\n      }\r\n      this.scrollToPosition(scroll)\r\n    },\r\n\r\n    scrollToPosition (position) {\r\n      if (this.direction === 'vertical') {\r\n        this.$el.scrollTop = position\r\n      } else {\r\n        this.$el.scrollLeft = position\r\n      }\r\n    },\r\n\r\n    itemsLimitError () {\r\n      setTimeout(() => {\r\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\r\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\r\n      })\r\n      throw new Error('Rendered items limit reached')\r\n    },\r\n\r\n    sortViews () {\r\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\r\n    },\r\n  },\r\n})\r\n</script>\r\n\r\n<style>\r\n.vue-recycle-scroller {\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\r\n  overflow-y: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\r\n  overflow-x: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal {\r\n  display: flex;\r\n}\r\n\r\n.vue-recycle-scroller__slot {\r\n  flex: auto 0 0;\r\n}\r\n\r\n.vue-recycle-scroller__item-wrapper {\r\n  flex: 1;\r\n  box-sizing: border-box;\r\n  overflow: hidden;\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  will-change: transform;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\r\n  height: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\r\n  height: 100%;\r\n}\r\n</style>\r\n", "<template>\r\n  <div\r\n    v-observe-visibility=\"handleVisibilityChange\"\r\n    class=\"vue-recycle-scroller\"\r\n    :class=\"{\r\n      ready,\r\n      'page-mode': pageMode,\r\n      [`direction-${direction}`]: true,\r\n    }\"\r\n    @scroll.passive=\"handleScroll\"\r\n  >\r\n    <div\r\n      v-if=\"$slots.before\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"before\"\r\n      />\r\n    </div>\r\n\r\n    <div\r\n      ref=\"wrapper\"\r\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\r\n      class=\"vue-recycle-scroller__item-wrapper\"\r\n    >\r\n      <div\r\n        v-for=\"view of pool\"\r\n        :key=\"view.nr.id\"\r\n        :style=\"ready ? { transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px)` } : null\"\r\n        class=\"vue-recycle-scroller__item-view\"\r\n        :class=\"{ hover: hoverKey === view.nr.key }\"\r\n        @mouseenter=\"hoverKey = view.nr.key\"\r\n        @mouseleave=\"hoverKey = null\"\r\n      >\r\n        <slot\r\n          :item=\"view.item\"\r\n          :index=\"view.nr.index\"\r\n          :active=\"view.nr.used\"\r\n        />\r\n      </div>\r\n    </div>\r\n\r\n    <div\r\n      v-if=\"$slots.after\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"after\"\r\n      />\r\n    </div>\r\n\r\n    <ResizeObserver @notify=\"handleResize\" />\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { ResizeObserver } from 'vue3-resize'\r\nimport { ObserveVisibility } from 'vue3-observe-visibility2'\r\nimport config from '../config'\r\nimport { props, simpleArray, scrollParent } from './common'\r\nimport {supportsPassive} from '../utils'\r\nimport {defineComponent} from 'vue'\r\n\r\nlet uid = 0\r\n\r\nexport default defineComponent({\r\n  name: 'RecycleScroller',\r\n\r\n  components: {\r\n    ResizeObserver,\r\n  },\r\n\r\n  directives: {\r\n    ObserveVisibility,\r\n  },\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    itemSize: {\r\n      type: Number,\r\n      default: null,\r\n    },\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      default: null,\r\n    },\r\n\r\n    sizeField: {\r\n      type: String,\r\n      default: 'size',\r\n    },\r\n\r\n    typeField: {\r\n      type: String,\r\n      default: 'type',\r\n    },\r\n\r\n    buffer: {\r\n      type: Number,\r\n      default: 200,\r\n    },\r\n\r\n    pageMode: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    prerender: {\r\n      type: Number,\r\n      default: 0,\r\n    },\r\n\r\n    emitUpdate: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n  },\r\n\r\n  emits: ['visible', 'hidden', 'resize', 'update'],\r\n\r\n  data () {\r\n    return {\r\n      pool: [],\r\n      totalSize: 0,\r\n      ready: false,\r\n      hoverKey: null,\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    sizes () {\r\n      if (this.itemSize === null) {\r\n        const sizes = {\r\n          '-1': { accumulator: 0 },\r\n        }\r\n        const items = this.items\r\n        const field = this.sizeField\r\n        const minItemSize = this.minItemSize\r\n        let computedMinSize = 10000\r\n        let accumulator = 0\r\n        let current\r\n        for (let i = 0, l = items.length; i < l; i++) {\r\n          current = items[i][field] || minItemSize\r\n          if (current < computedMinSize) {\r\n            computedMinSize = current\r\n          }\r\n          accumulator += current\r\n          sizes[i] = { accumulator, size: current }\r\n        }\r\n        // eslint-disable-next-line\r\n        this.$_computedMinItemSize = computedMinSize\r\n        return sizes\r\n      }\r\n      return []\r\n    },\r\n\r\n    simpleArray,\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.updateVisibleItems(true)\r\n    },\r\n\r\n    pageMode () {\r\n      this.applyPageMode()\r\n      this.updateVisibleItems(false)\r\n    },\r\n\r\n    sizes: {\r\n      handler () {\r\n        this.updateVisibleItems(false)\r\n      },\r\n      deep: true,\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_startIndex = 0\r\n    this.$_endIndex = 0\r\n    this.$_views = new Map()\r\n    this.$_unusedViews = new Map()\r\n    this.$_scrollDirty = false\r\n    this.$_lastUpdateScrollPosition = 0\r\n\r\n    // In SSR mode, we also prerender the same number of item for the first render\r\n    // to avoir mismatch between server and client templates\r\n    if (this.prerender) {\r\n      this.$_prerender = true\r\n      this.updateVisibleItems(false)\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    this.applyPageMode()\r\n    this.$nextTick(() => {\r\n      // In SSR mode, render the real number of visible items\r\n      this.$_prerender = false\r\n      this.updateVisibleItems(true)\r\n      this.ready = true\r\n    })\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.removeListeners()\r\n  },\r\n\r\n  methods: {\r\n    addView (pool, index, item, key, type) {\r\n      const view = {\r\n        item,\r\n        position: 0,\r\n      }\r\n      view.nr = {\r\n        id: uid++,\r\n        index,\r\n        used: true,\r\n        key,\r\n        type,\r\n      }\r\n      pool.push(view)\r\n      return view\r\n    },\r\n\r\n    unuseView (view, fake = false) {\r\n      const unusedViews = this.$_unusedViews\r\n      const type = view.nr.type\r\n      let unusedPool = unusedViews.get(type)\r\n      if (!unusedPool) {\r\n        unusedPool = []\r\n        unusedViews.set(type, unusedPool)\r\n      }\r\n      unusedPool.push(view)\r\n      if (!fake) {\r\n        view.nr.used = false\r\n        view.position = -9999\r\n        this.$_views.delete(view.nr.key)\r\n      }\r\n    },\r\n\r\n    handleResize () {\r\n      this.$emit('resize')\r\n      if (this.ready) this.updateVisibleItems(false)\r\n    },\r\n\r\n    handleScroll (event) {\r\n      if (!this.$_scrollDirty) {\r\n        this.$_scrollDirty = true\r\n        requestAnimationFrame(() => {\r\n          this.$_scrollDirty = false\r\n          const { continuous } = this.updateVisibleItems(false, true)\r\n\r\n          // It seems sometimes chrome doesn't fire scroll event :/\r\n          // When non continous scrolling is ending, we force a refresh\r\n          if (!continuous) {\r\n            clearTimeout(this.$_refreshTimout)\r\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100)\r\n          }\r\n        })\r\n      }\r\n    },\r\n\r\n    handleVisibilityChange (isVisible, entry) {\r\n      if (this.ready) {\r\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\r\n          this.$emit('visible')\r\n          requestAnimationFrame(() => {\r\n            this.updateVisibleItems(false)\r\n          })\r\n        } else {\r\n          this.$emit('hidden')\r\n        }\r\n      }\r\n    },\r\n\r\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\r\n      const itemSize = this.itemSize\r\n      const minItemSize = this.$_computedMinItemSize\r\n      const typeField = this.typeField\r\n      const keyField = this.simpleArray ? null : this.keyField\r\n      const items = this.items\r\n      const count = items.length\r\n      const sizes = this.sizes\r\n      const views = this.$_views\r\n      const unusedViews = this.$_unusedViews\r\n      const pool = this.pool\r\n      let startIndex, endIndex\r\n      let totalSize\r\n\r\n      if (!count) {\r\n        startIndex = endIndex = totalSize = 0\r\n      } else if (this.$_prerender) {\r\n        startIndex = 0\r\n        endIndex = this.prerender\r\n        totalSize = null\r\n      } else {\r\n        const scroll = this.getScroll()\r\n\r\n        // Skip update if use hasn't scrolled enough\r\n        if (checkPositionDiff) {\r\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\r\n          if (positionDiff < 0) positionDiff = -positionDiff\r\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\r\n            return {\r\n              continuous: true,\r\n            }\r\n          }\r\n        }\r\n        this.$_lastUpdateScrollPosition = scroll.start\r\n\r\n        const buffer = this.buffer\r\n        scroll.start -= buffer\r\n        scroll.end += buffer\r\n\r\n        // Variable size mode\r\n        if (itemSize === null) {\r\n          let h\r\n          let a = 0\r\n          let b = count - 1\r\n          let i = ~~(count / 2)\r\n          let oldI\r\n\r\n          // Searching for startIndex\r\n          do {\r\n            oldI = i\r\n            h = sizes[i].accumulator\r\n            if (h < scroll.start) {\r\n              a = i\r\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\r\n              b = i\r\n            }\r\n            i = ~~((a + b) / 2)\r\n          } while (i !== oldI)\r\n          i < 0 && (i = 0)\r\n          startIndex = i\r\n\r\n          // For container style\r\n          totalSize = sizes[count - 1].accumulator\r\n\r\n          // Searching for endIndex\r\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\r\n          if (endIndex === -1) {\r\n            endIndex = items.length - 1\r\n          } else {\r\n            endIndex++\r\n            // Bounds\r\n            endIndex > count && (endIndex = count)\r\n          }\r\n        } else {\r\n          // Fixed size mode\r\n          startIndex = ~~(scroll.start / itemSize)\r\n          endIndex = Math.ceil(scroll.end / itemSize)\r\n\r\n          // Bounds\r\n          startIndex < 0 && (startIndex = 0)\r\n          endIndex > count && (endIndex = count)\r\n\r\n          totalSize = count * itemSize\r\n        }\r\n      }\r\n\r\n      if (endIndex - startIndex > config.itemsLimit) {\r\n        this.itemsLimitError()\r\n      }\r\n\r\n      this.totalSize = totalSize\r\n\r\n      let view\r\n\r\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\r\n\r\n      if (this.$_continuous !== continuous) {\r\n        if (continuous) {\r\n          views.clear()\r\n          unusedViews.clear()\r\n          for (let i = 0, l = pool.length; i < l; i++) {\r\n            view = pool[i]\r\n            this.unuseView(view)\r\n          }\r\n        }\r\n        this.$_continuous = continuous\r\n      } else if (continuous) {\r\n        for (let i = 0, l = pool.length; i < l; i++) {\r\n          view = pool[i]\r\n          if (view.nr.used) {\r\n            // Update view item index\r\n            if (checkItem) {\r\n              view.nr.index = items.findIndex(\r\n                item => keyField ? item[keyField] === view.item[keyField] : item === view.item,\r\n              )\r\n            }\r\n\r\n            // Check if index is still in visible range\r\n            if (\r\n              view.nr.index === -1 ||\r\n              view.nr.index < startIndex ||\r\n              view.nr.index >= endIndex\r\n            ) {\r\n              this.unuseView(view)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const unusedIndex = continuous ? null : new Map()\r\n\r\n      let item, type, unusedPool\r\n      let v\r\n      for (let i = startIndex; i < endIndex; i++) {\r\n        item = items[i]\r\n        const key = keyField ? item[keyField] : item\r\n        if (key == null) {\r\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\r\n        }\r\n        view = views.get(key)\r\n\r\n        if (!itemSize && !sizes[i].size) {\r\n          if (view) this.unuseView(view)\r\n          continue\r\n        }\r\n\r\n        // No view assigned to item\r\n        if (!view) {\r\n          type = item[typeField]\r\n          unusedPool = unusedViews.get(type)\r\n\r\n          if (continuous) {\r\n            // Reuse existing view\r\n            if (unusedPool && unusedPool.length) {\r\n              view = unusedPool.pop()\r\n              view.item = item\r\n              view.nr.used = true\r\n              view.nr.index = i\r\n              view.nr.key = key\r\n              view.nr.type = type\r\n            } else {\r\n              view = this.addView(pool, i, item, key, type)\r\n            }\r\n          } else {\r\n            // Use existing view\r\n            // We don't care if they are already used\r\n            // because we are not in continous scrolling\r\n            v = unusedIndex.get(type) || 0\r\n\r\n            if (!unusedPool || v >= unusedPool.length) {\r\n              view = this.addView(pool, i, item, key, type)\r\n              this.unuseView(view, true)\r\n              unusedPool = unusedViews.get(type)\r\n            }\r\n\r\n            view = unusedPool[v]\r\n            view.item = item\r\n            view.nr.used = true\r\n            view.nr.index = i\r\n            view.nr.key = key\r\n            view.nr.type = type\r\n            unusedIndex.set(type, v + 1)\r\n            v++\r\n          }\r\n          views.set(key, view)\r\n        } else {\r\n          view.nr.used = true\r\n          view.item = item\r\n        }\r\n\r\n        // Update position\r\n        if (itemSize === null) {\r\n          view.position = sizes[i - 1].accumulator\r\n        } else {\r\n          view.position = i * itemSize\r\n        }\r\n      }\r\n\r\n      this.$_startIndex = startIndex\r\n      this.$_endIndex = endIndex\r\n\r\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex)\r\n\r\n      // After the user has finished scrolling\r\n      // Sort views so text selection is correct\r\n      clearTimeout(this.$_sortTimer)\r\n      this.$_sortTimer = setTimeout(this.sortViews, 300)\r\n\r\n      return {\r\n        continuous,\r\n      }\r\n    },\r\n\r\n    getListenerTarget () {\r\n      let target = scrollParent(this.$el)\r\n      // Fix global scroll target for Chrome and Safari\r\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\r\n        target = window\r\n      }\r\n      return target\r\n    },\r\n\r\n    getScroll () {\r\n      const { $el: el, direction } = this\r\n      const isVertical = direction === 'vertical'\r\n      let scrollState\r\n\r\n      if (this.pageMode) {\r\n        const bounds = el.getBoundingClientRect()\r\n        const boundsSize = isVertical ? bounds.height : bounds.width\r\n        let start = -(isVertical ? bounds.top : bounds.left)\r\n        let size = isVertical ? window.innerHeight : window.innerWidth\r\n        if (start < 0) {\r\n          size += start\r\n          start = 0\r\n        }\r\n        if (start + size > boundsSize) {\r\n          size = boundsSize - start\r\n        }\r\n        scrollState = {\r\n          start,\r\n          end: start + size,\r\n        }\r\n      } else if (isVertical) {\r\n        scrollState = {\r\n          start: el.scrollTop,\r\n          end: el.scrollTop + el.clientHeight,\r\n        }\r\n      } else {\r\n        scrollState = {\r\n          start: el.scrollLeft,\r\n          end: el.scrollLeft + el.clientWidth,\r\n        }\r\n      }\r\n\r\n      return scrollState\r\n    },\r\n\r\n    applyPageMode () {\r\n      if (this.pageMode) {\r\n        this.addListeners()\r\n      } else {\r\n        this.removeListeners()\r\n      }\r\n    },\r\n\r\n    addListeners () {\r\n      this.listenerTarget = this.getListenerTarget()\r\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive ? {\r\n        passive: true,\r\n      } : false)\r\n      this.listenerTarget.addEventListener('resize', this.handleResize)\r\n    },\r\n\r\n    removeListeners () {\r\n      if (!this.listenerTarget) {\r\n        return\r\n      }\r\n\r\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\r\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\r\n\r\n      this.listenerTarget = null\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      let scroll\r\n      if (this.itemSize === null) {\r\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\r\n      } else {\r\n        scroll = index * this.itemSize\r\n      }\r\n      this.scrollToPosition(scroll)\r\n    },\r\n\r\n    scrollToPosition (position) {\r\n      if (this.direction === 'vertical') {\r\n        this.$el.scrollTop = position\r\n      } else {\r\n        this.$el.scrollLeft = position\r\n      }\r\n    },\r\n\r\n    itemsLimitError () {\r\n      setTimeout(() => {\r\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\r\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\r\n      })\r\n      throw new Error('Rendered items limit reached')\r\n    },\r\n\r\n    sortViews () {\r\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\r\n    },\r\n  },\r\n})\r\n</script>\r\n\r\n<style>\r\n.vue-recycle-scroller {\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\r\n  overflow-y: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\r\n  overflow-x: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal {\r\n  display: flex;\r\n}\r\n\r\n.vue-recycle-scroller__slot {\r\n  flex: auto 0 0;\r\n}\r\n\r\n.vue-recycle-scroller__item-wrapper {\r\n  flex: 1;\r\n  box-sizing: border-box;\r\n  overflow: hidden;\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  will-change: transform;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\r\n  height: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\r\n  height: 100%;\r\n}\r\n</style>\r\n", "<template>\r\n  <RecycleScroller\r\n    ref=\"scroller\"\r\n    :items=\"itemsWithSize\"\r\n    :min-item-size=\"minItemSize\"\r\n    :direction=\"direction\"\r\n    key-field=\"id\"\r\n    v-bind=\"$attrs\"\r\n    @resize=\"onScrollerResize\"\r\n    @visible=\"onScrollerVisible\"\r\n    v-on=\"listeners\"\r\n  >\r\n    <template #default=\"{ item: itemWithSize, index, active }\">\r\n      <slot\r\n        v-bind=\"{\r\n          item: itemWithSize.item,\r\n          index,\r\n          active,\r\n          itemWithSize\r\n        }\"\r\n      />\r\n    </template>\r\n    <template #before>\r\n      <slot name=\"before\" />\r\n    </template>\r\n    <template #after>\r\n      <slot name=\"after\" />\r\n    </template>\r\n  </RecycleScroller>\r\n</template>\r\n\r\n<script>\r\nimport RecycleScroller from './RecycleScroller.vue'\r\nimport { props, simpleArray } from './common'\r\n\r\nexport default {\r\n  name: 'DynamicScroller',\r\n\r\n  components: {\r\n    RecycleScroller,\r\n  },\r\n\r\n  provide () {\r\n    let vscrollResizeObserver = undefined\r\n\r\n    if (typeof ResizeObserver !== 'undefined') {\r\n      vscrollResizeObserver = new ResizeObserver(entries => {\r\n        for (const entry of entries) {\r\n          if (entry.target) {\r\n            const event = new CustomEvent('resize', {\r\n                detail: {\r\n                  contentRect: entry.contentRect,\r\n                },\r\n              },\r\n            )\r\n            entry.target.dispatchEvent(event)\r\n          }\r\n        }\r\n      })\r\n    }\r\n\r\n    return {\r\n      vscrollData: this.vscrollData,\r\n      vscrollParent: this,\r\n      vscrollResizeObserver,\r\n      onUpdateScroll: (cb) => this.vScrollMap.push(cb),\r\n    }\r\n  },\r\n\r\n  inheritAttrs: false,\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      required: true,\r\n    },\r\n  },\r\n\r\n  emits: ['vscroll:update', 'resize', 'visible'],\r\n\r\n  data () {\r\n    return {\r\n      vscrollData: {\r\n        active: true,\r\n        sizes: {},\r\n        validSizes: {},\r\n        keyField: this.keyField,\r\n        simpleArray: false,\r\n      },\r\n      vScrollMap: [],\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    simpleArray,\r\n\r\n    itemsWithSize () {\r\n      const result = []\r\n      const { items, keyField, simpleArray } = this\r\n      const sizes = this.vscrollData.sizes\r\n      for (let i = 0; i < items.length; i++) {\r\n        const item = items[i]\r\n        const id = simpleArray ? i : item[keyField]\r\n        let size = sizes[id]\r\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\r\n          size = 0\r\n        }\r\n        result.push({\r\n          item,\r\n          id,\r\n          size,\r\n        })\r\n      }\r\n      return result\r\n    },\r\n\r\n    listeners () {\r\n      const listeners = {}\r\n\r\n      for (const key in this.$attrs) {\r\n        if (key.startsWith('on')) {\r\n          if (key !== 'onResize' && key !== 'onVisible') {\r\n            listeners[key] = this.$attrs\r\n          }\r\n        }\r\n      }\r\n\r\n      return listeners\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.forceUpdate(false)\r\n    },\r\n\r\n    simpleArray: {\r\n      handler (value) {\r\n        this.vscrollData.simpleArray = value\r\n      },\r\n      immediate: true,\r\n    },\r\n\r\n    direction (value) {\r\n      this.forceUpdate(true)\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_updates = []\r\n    this.$_undefinedSizes = 0\r\n    this.$_undefinedMap = {}\r\n  },\r\n\r\n  activated () {\r\n    this.vscrollData.active = true\r\n  },\r\n\r\n  deactivated () {\r\n    this.vscrollData.active = false\r\n  },\r\n\r\n  methods: {\r\n    onScrollerResize () {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) {\r\n        this.forceUpdate()\r\n      }\r\n      this.$emit('resize')\r\n    },\r\n\r\n    onScrollerVisible () {\r\n      this.vScrollUpdate(false)\r\n      this.$emit('visible')\r\n    },\r\n\r\n    vScrollUpdate(force = false) {\r\n      const data = { force }\r\n      this.$emit('vscroll:update', data)\r\n\r\n      this.vScrollMap.forEach(callback => callback(data))\r\n    },\r\n\r\n    forceUpdate (clear = true) {\r\n      if (clear || this.simpleArray) {\r\n        this.vscrollData.validSizes = {}\r\n      }\r\n      this.vScrollUpdate(true)\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) scroller.scrollToItem(index)\r\n    },\r\n\r\n    getItemSize (item, index = undefined) {\r\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\r\n      return this.vscrollData.sizes[id] || 0\r\n    },\r\n\r\n    scrollToBottom () {\r\n      if (this.$_scrollingToBottom) return\r\n      this.$_scrollingToBottom = true\r\n      const el = this.$el\r\n      // Item is inserted to the DOM\r\n      this.$nextTick(() => {\r\n        el.scrollTop = el.scrollHeight + 5000\r\n        // Item sizes are computed\r\n        const cb = () => {\r\n          el.scrollTop = el.scrollHeight + 5000\r\n          requestAnimationFrame(() => {\r\n            el.scrollTop = el.scrollHeight + 5000\r\n            if (this.$_undefinedSizes === 0) {\r\n              this.$_scrollingToBottom = false\r\n            } else {\r\n              requestAnimationFrame(cb)\r\n            }\r\n          })\r\n        }\r\n        requestAnimationFrame(cb)\r\n      })\r\n    },\r\n  },\r\n}\r\n</script>\r\n", "<template>\r\n  <RecycleScroller\r\n    ref=\"scroller\"\r\n    :items=\"itemsWithSize\"\r\n    :min-item-size=\"minItemSize\"\r\n    :direction=\"direction\"\r\n    key-field=\"id\"\r\n    v-bind=\"$attrs\"\r\n    @resize=\"onScrollerResize\"\r\n    @visible=\"onScrollerVisible\"\r\n    v-on=\"listeners\"\r\n  >\r\n    <template #default=\"{ item: itemWithSize, index, active }\">\r\n      <slot\r\n        v-bind=\"{\r\n          item: itemWithSize.item,\r\n          index,\r\n          active,\r\n          itemWithSize\r\n        }\"\r\n      />\r\n    </template>\r\n    <template #before>\r\n      <slot name=\"before\" />\r\n    </template>\r\n    <template #after>\r\n      <slot name=\"after\" />\r\n    </template>\r\n  </RecycleScroller>\r\n</template>\r\n\r\n<script>\r\nimport RecycleScroller from './RecycleScroller.vue'\r\nimport { props, simpleArray } from './common'\r\n\r\nexport default {\r\n  name: 'DynamicScroller',\r\n\r\n  components: {\r\n    RecycleScroller,\r\n  },\r\n\r\n  provide () {\r\n    let vscrollResizeObserver = undefined\r\n\r\n    if (typeof ResizeObserver !== 'undefined') {\r\n      vscrollResizeObserver = new ResizeObserver(entries => {\r\n        for (const entry of entries) {\r\n          if (entry.target) {\r\n            const event = new CustomEvent('resize', {\r\n                detail: {\r\n                  contentRect: entry.contentRect,\r\n                },\r\n              },\r\n            )\r\n            entry.target.dispatchEvent(event)\r\n          }\r\n        }\r\n      })\r\n    }\r\n\r\n    return {\r\n      vscrollData: this.vscrollData,\r\n      vscrollParent: this,\r\n      vscrollResizeObserver,\r\n      onUpdateScroll: (cb) => this.vScrollMap.push(cb),\r\n    }\r\n  },\r\n\r\n  inheritAttrs: false,\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      required: true,\r\n    },\r\n  },\r\n\r\n  emits: ['vscroll:update', 'resize', 'visible'],\r\n\r\n  data () {\r\n    return {\r\n      vscrollData: {\r\n        active: true,\r\n        sizes: {},\r\n        validSizes: {},\r\n        keyField: this.keyField,\r\n        simpleArray: false,\r\n      },\r\n      vScrollMap: [],\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    simpleArray,\r\n\r\n    itemsWithSize () {\r\n      const result = []\r\n      const { items, keyField, simpleArray } = this\r\n      const sizes = this.vscrollData.sizes\r\n      for (let i = 0; i < items.length; i++) {\r\n        const item = items[i]\r\n        const id = simpleArray ? i : item[keyField]\r\n        let size = sizes[id]\r\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\r\n          size = 0\r\n        }\r\n        result.push({\r\n          item,\r\n          id,\r\n          size,\r\n        })\r\n      }\r\n      return result\r\n    },\r\n\r\n    listeners () {\r\n      const listeners = {}\r\n\r\n      for (const key in this.$attrs) {\r\n        if (key.startsWith('on')) {\r\n          if (key !== 'onResize' && key !== 'onVisible') {\r\n            listeners[key] = this.$attrs\r\n          }\r\n        }\r\n      }\r\n\r\n      return listeners\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.forceUpdate(false)\r\n    },\r\n\r\n    simpleArray: {\r\n      handler (value) {\r\n        this.vscrollData.simpleArray = value\r\n      },\r\n      immediate: true,\r\n    },\r\n\r\n    direction (value) {\r\n      this.forceUpdate(true)\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_updates = []\r\n    this.$_undefinedSizes = 0\r\n    this.$_undefinedMap = {}\r\n  },\r\n\r\n  activated () {\r\n    this.vscrollData.active = true\r\n  },\r\n\r\n  deactivated () {\r\n    this.vscrollData.active = false\r\n  },\r\n\r\n  methods: {\r\n    onScrollerResize () {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) {\r\n        this.forceUpdate()\r\n      }\r\n      this.$emit('resize')\r\n    },\r\n\r\n    onScrollerVisible () {\r\n      this.vScrollUpdate(false)\r\n      this.$emit('visible')\r\n    },\r\n\r\n    vScrollUpdate(force = false) {\r\n      const data = { force }\r\n      this.$emit('vscroll:update', data)\r\n\r\n      this.vScrollMap.forEach(callback => callback(data))\r\n    },\r\n\r\n    forceUpdate (clear = true) {\r\n      if (clear || this.simpleArray) {\r\n        this.vscrollData.validSizes = {}\r\n      }\r\n      this.vScrollUpdate(true)\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) scroller.scrollToItem(index)\r\n    },\r\n\r\n    getItemSize (item, index = undefined) {\r\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\r\n      return this.vscrollData.sizes[id] || 0\r\n    },\r\n\r\n    scrollToBottom () {\r\n      if (this.$_scrollingToBottom) return\r\n      this.$_scrollingToBottom = true\r\n      const el = this.$el\r\n      // Item is inserted to the DOM\r\n      this.$nextTick(() => {\r\n        el.scrollTop = el.scrollHeight + 5000\r\n        // Item sizes are computed\r\n        const cb = () => {\r\n          el.scrollTop = el.scrollHeight + 5000\r\n          requestAnimationFrame(() => {\r\n            el.scrollTop = el.scrollHeight + 5000\r\n            if (this.$_undefinedSizes === 0) {\r\n              this.$_scrollingToBottom = false\r\n            } else {\r\n              requestAnimationFrame(cb)\r\n            }\r\n          })\r\n        }\r\n        requestAnimationFrame(cb)\r\n      })\r\n    },\r\n  },\r\n}\r\n</script>\r\n", "import { createVNode, nextTick } from 'vue';\r\n\r\nexport default {\r\n  name: 'DynamicScrollerItem',\r\n\r\n  inject: [\r\n    'vscrollData',\r\n    'vscrollParent',\r\n    'onUpdateScroll',\r\n    'vscrollResizeObserver',\r\n  ],\r\n\r\n  props: {\r\n    item: {\r\n      required: true,\r\n    },\r\n\r\n    watchData: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    /**\r\n     * Indicates if the view is actively used to display an item.\r\n     */\r\n    active: {\r\n      type: Boolean,\r\n      required: true,\r\n    },\r\n\r\n    index: {\r\n      type: Number,\r\n      default: undefined,\r\n    },\r\n\r\n    sizeDependencies: {\r\n      type: [Array, Object],\r\n      default: null,\r\n    },\r\n\r\n    emitResize: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    tag: {\r\n      type: String,\r\n      default: 'div',\r\n    },\r\n  },\r\n\r\n  computed: {\r\n    id () {\r\n      return this.vscrollData.simpleArray ? this.index : this.item[this.vscrollData.keyField];\r\n    },\r\n\r\n    size () {\r\n      return (this.vscrollData.validSizes[this.id] && this.vscrollData.sizes[this.id]) || 0;\r\n    },\r\n\r\n    finalActive () {\r\n      return this.active && this.vscrollData.active;\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    watchData: 'updateWatchData',\r\n\r\n    id () {\r\n      if (!this.size) {\r\n        this.onDataUpdate();\r\n      }\r\n    },\r\n\r\n    finalActive (value) {\r\n      if (!this.size) {\r\n        if (value) {\r\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\r\n            this.vscrollParent.$_undefinedSizes++;\r\n            this.vscrollParent.$_undefinedMap[this.id] = true;\r\n          }\r\n        } else {\r\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\r\n            this.vscrollParent.$_undefinedSizes--;\r\n            this.vscrollParent.$_undefinedMap[this.id] = false;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this.vscrollResizeObserver) {\r\n        if (value) {\r\n          this.observeSize();\r\n        } else {\r\n          this.unobserveSize();\r\n        }\r\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\r\n        this.updateSize();\r\n      }\r\n    },\r\n  },\r\n\r\n  created () {\r\n    if (this.$isServer) return;\r\n\r\n    this.$_forceNextVScrollUpdate = null;\r\n    this.updateWatchData();\r\n\r\n    if (!this.vscrollResizeObserver) {\r\n      for (const k in this.sizeDependencies) {\r\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate);\r\n      }\r\n\r\n      this.onUpdateScroll('vscroll:update', this.onVscrollUpdate);\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    if (this.vscrollData.active) {\r\n      this.updateSize();\r\n      this.observeSize();\r\n    }\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.unobserveSize();\r\n  },\r\n\r\n  methods: {\r\n    updateSize () {\r\n      if (this.finalActive) {\r\n        if (this.$_pendingSizeUpdate !== this.id) {\r\n          this.$_pendingSizeUpdate = this.id;\r\n          this.$_forceNextVScrollUpdate = null;\r\n          this.$_pendingVScrollUpdate = null;\r\n          this.computeSize(this.id);\r\n        }\r\n      } else {\r\n        this.$_forceNextVScrollUpdate = this.id;\r\n      }\r\n    },\r\n\r\n    updateWatchData () {\r\n      if (this.watchData) {\r\n        this.$_watchData = this.$watch('data', () => {\r\n          this.onDataUpdate();\r\n        }, {\r\n          deep: true,\r\n        });\r\n      } else if (this.$_watchData) {\r\n        this.$_watchData();\r\n        this.$_watchData = null;\r\n      }\r\n    },\r\n\r\n    onVscrollUpdate ({ force }) {\r\n      // If not active, sechedule a size update when it becomes active\r\n      if (!this.finalActive && force) {\r\n        this.$_pendingVScrollUpdate = this.id;\r\n      }\r\n\r\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\r\n        this.updateSize();\r\n      }\r\n    },\r\n\r\n    onDataUpdate () {\r\n      this.updateSize();\r\n    },\r\n\r\n    computeSize (id) {\r\n      nextTick(() => {\r\n        if (this.id === id) {\r\n          const width = this.$el.offsetWidth;\r\n          const height = this.$el.offsetHeight;\r\n          this.applySize(width, height);\r\n        }\r\n        this.$_pendingSizeUpdate = null;\r\n      }).then();\r\n    },\r\n\r\n    applySize (width, height) {\r\n      const size = Math.round(this.vscrollParent.direction === 'vertical' ? height : width);\r\n      if (size && this.size !== size) {\r\n        if (this.vscrollParent.$_undefinedMap[this.id]) {\r\n          this.vscrollParent.$_undefinedSizes--;\r\n          this.vscrollParent.$_undefinedMap[this.id] = undefined;\r\n        }\r\n        this.vscrollData.sizes[this.id] = size;\r\n        this.vscrollData.validSizes[this.id] = true;\r\n        if (this.emitResize) this.$emit('resize', this.id);\r\n      }\r\n    },\r\n\r\n    observeSize () {\r\n      if (!this.vscrollResizeObserver) return;\r\n      this.vscrollResizeObserver.observe(this.$el.parentNode);\r\n      this.$el.parentNode.addEventListener('resize', this.onResize);\r\n    },\r\n\r\n    unobserveSize () {\r\n      if (!this.vscrollResizeObserver) return;\r\n      this.vscrollResizeObserver.unobserve(this.$el.parentNode);\r\n      this.$el.parentNode.removeEventListener('resize', this.onResize);\r\n    },\r\n\r\n    onResize (event) {\r\n      const { width, height } = event.detail.contentRect;\r\n      this.applySize(width, height);\r\n    },\r\n  },\r\n\r\n  render () {\r\n    return createVNode(this.tag, null, this.$slots.default());\r\n  },\r\n};\r\n", "import config from './config'\r\n\r\nimport RecycleScroller from './components/RecycleScroller.vue'\r\nimport DynamicScroller from './components/DynamicScroller.vue'\r\nimport DynamicScrollerItem from './components/DynamicScrollerItem.js'\r\nimport { version } from '../package.json'\r\n\r\nexport {\r\n  RecycleScroller,\r\n  DynamicScroller,\r\n  DynamicScrollerItem,\r\n}\r\n\r\nfunction registerComponents (app, prefix) {\r\n  app.component(`${prefix}recycle-scroller`, RecycleScroller)\r\n  app.component(`${prefix}RecycleScroller`, RecycleScroller)\r\n  app.component(`${prefix}dynamic-scroller`, DynamicScroller)\r\n  app.component(`${prefix}DynamicScroller`, DynamicScroller)\r\n  app.component(`${prefix}dynamic-scroller-item`, DynamicScrollerItem)\r\n  app.component(`${prefix}DynamicScrollerItem`, DynamicScrollerItem)\r\n}\r\n\r\nconst plugin = {\r\n  version,\r\n  install (app, options) {\r\n    const finalOptions = Object.assign({}, {\r\n      installComponents: true,\r\n      componentsPrefix: '',\r\n    }, options)\r\n\r\n    for (const key in finalOptions) {\r\n      if (typeof finalOptions[key] !== 'undefined') {\r\n        config[key] = finalOptions[key]\r\n      }\r\n    }\r\n\r\n    if (finalOptions.installComponents) {\r\n      registerComponents(app, finalOptions.componentsPrefix)\r\n    }\r\n  },\r\n}\r\n\r\nexport default plugin\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAO,SAASA,6BAA8B;AAC5C,QAAMC,KAAKC,OAAOC,UAAUC;AAE5B,QAAMC,OAAOJ,GAAGK,QAAQ,OAAX;AACb,MAAID,OAAO,GAAG;AAEZ,WAAOE,SAASN,GAAGO,UAAUH,OAAO,GAAGJ,GAAGK,QAAQ,KAAKD,IAAhB,CAAvB,GAA+C,EAAhD;EAChB;AAED,QAAMI,UAAUR,GAAGK,QAAQ,UAAX;AAChB,MAAIG,UAAU,GAAG;AAEf,UAAMC,KAAKT,GAAGK,QAAQ,KAAX;AACX,WAAOC,SAASN,GAAGO,UAAUE,KAAK,GAAGT,GAAGK,QAAQ,KAAKI,EAAhB,CAArB,GAA2C,EAA5C;EAChB;AAED,QAAMC,OAAOV,GAAGK,QAAQ,OAAX;AACb,MAAIK,OAAO,GAAG;AAEZ,WAAOJ,SAASN,GAAGO,UAAUG,OAAO,GAAGV,GAAGK,QAAQ,KAAKK,IAAhB,CAAvB,GAA+C,EAAhD;EAChB;AAGD,SAAO;AACR;ACZD,IAAIC;AAEJ,SAASC,aAAc;AACrB,MAAI,CAACA,WAAWC,MAAM;AACpBD,eAAWC,OAAO;AAClBF,WAAOZ,2BAA0B,MAAO;;;AAI5C,IAAA,SAAe;EACbe,MAAM;EAENC,OAAO;IACLC,aAAa;MACXC,MAAMC;MACNC,SAAS;IAFE;EADR;EAOPC,OAAO,CAAC,QAAD;EAEPC,MAAON,QAAO;IAAEO;EAAF,GAAU;AACtB,QAAIC,KAAK;AACT,QAAIC,KAAK;AACT,UAAMC,QAAQC,IAAI,IAAD;AACjB,QAAIC,gBAAgB;AAEpB,UAAMC,mBAAmB,MAAM;AAC7B,UAAIL,OAAOE,MAAMI,MAAMC,eAAeN,OAAOC,MAAMI,MAAME,cAAc;AACrER,aAAKE,MAAMI,MAAMC;AACjBN,aAAKC,MAAMI,MAAME;AAEjBT,aAAK,UAAU;UACbU,OAAOT;UACPU,QAAQT;QAFK,CAAX;;;AAOR,UAAMU,oBAAoB,MAAM;AAC9BP,oBAAcQ,gBAAgBC,YAAYC,iBAAiB,UAAUT,gBAArE;AACAA,uBAAgB;;AAGlB,UAAMU,uBAAuB,MAAM;AACjC,UAAIX,iBAAiBA,cAAcY,QAAQ;AACzC,YAAI,CAAC5B,QAAQgB,cAAcQ,iBAAiB;AAC1CR,wBAAcQ,gBAAgBC,YAAYI,oBAAoB,UAAUZ,gBAAxE;;AAGFH,cAAMI,MAAMY,YAAYd,aAAxB;AAEAA,sBAAcY,SAAS;AACvBZ,wBAAgB;;;AAIpBe,cAAU,MAAM;AACd9B,iBAAU;AAEVW,WAAKE,MAAMI,MAAMC;AACjBN,WAAKC,MAAMI,MAAME;AAEjB,YAAMY,SAASC,SAASC,cAAc,QAAvB;AACflB,sBAAgBgB;AAEhBA,aAAOG,aAAa,eAAe,MAAnC;AACAH,aAAOG,aAAa,YAAY,IAAhC;AACAH,aAAOJ,SAASL;AAChBS,aAAO1B,OAAO;AAEd,UAAIN,MAAM;AACRc,cAAMI,MAAMkB,YAAYJ,MAAxB;;AAGFA,aAAOK,OAAO;AAEd,UAAI,CAACrC,MAAM;AACTc,cAAMI,MAAMkB,YAAYJ,MAAxB;;AAGF,UAAI5B,OAAMC,aAAa;AACrBY,yBAAgB;;IAEnB,CA3BQ;AA6BTqB,oBAAgB,MAAM;AACpBX,2BAAoB;IACrB,CAFc;AAIf,WAAO;MAAEb;IAAF;EACR;AAlFY;;ECnBXC,KAAI;EACJwB,OAAM;EACNC,UAAS;;;sBAHXC;IAAAA;IAAAC;IAAAA;IAAAA;;;;;;ACCFC,OAAeC,UAAU,SAAUC,KAAK;AACtCA,MAAIC,UAAUH,OAAexC,MAAMwC,MAAnC;AACD;;;AEJD,IAAA,SAAe;EACbI,YAAY;AADC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAf,SAASC,UAAQ,KAAK;AACpB,MAAI,OAAO,WAAW,cAAc,OAAO,OAAO,aAAa,UAAU;AACvEA,gBAAU,SAAUC,MAAK;AACvB,aAAO,OAAOA;IACpB;EACA,OAAS;AACLD,gBAAU,SAAUC,MAAK;AACvB,aAAOA,QAAO,OAAO,WAAW,cAAcA,KAAI,gBAAgB,UAAUA,SAAQ,OAAO,YAAY,WAAW,OAAOA;IAC/H;EACA;AAEE,SAAOD,UAAQ,GAAG;AACpB;AAEA,SAAS,gBAAgB,UAAU,aAAa;AAC9C,MAAI,EAAE,oBAAoB,cAAc;AACtC,UAAM,IAAI,UAAU,mCAAmC;EAC3D;AACA;AAEA,SAAS,kBAAkB,QAAQE,QAAO;AACxC,WAAS,IAAI,GAAG,IAAIA,OAAM,QAAQ,KAAK;AACrC,QAAI,aAAaA,OAAM,CAAC;AACxB,eAAW,aAAa,WAAW,cAAc;AACjD,eAAW,eAAe;AAC1B,QAAI,WAAW,WAAY,YAAW,WAAW;AACjD,WAAO,eAAe,QAAQ,WAAW,KAAK,UAAU;EAC5D;AACA;AAEA,SAAS,aAAa,aAAa,YAAY,aAAa;AAC1D,MAAI,WAAY,mBAAkB,YAAY,WAAW,UAAU;AACnE,MAAI,YAAa,mBAAkB,aAAa,WAAW;AAC3D,SAAO;AACT;AAEA,SAAS,mBAAmB,KAAK;AAC/B,SAAO,mBAAmB,GAAG,KAAK,iBAAiB,GAAG,KAAK,mBAAkB;AAC/E;AAEA,SAAS,mBAAmB,KAAK;AAC/B,MAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,aAAS,IAAI,GAAG,OAAO,IAAI,MAAM,IAAI,MAAM,GAAG,IAAI,IAAI,QAAQ,IAAK,MAAK,CAAC,IAAI,IAAI,CAAC;AAElF,WAAO;EACX;AACA;AAEA,SAAS,iBAAiB,MAAM;AAC9B,MAAI,OAAO,YAAY,OAAO,IAAI,KAAK,OAAO,UAAU,SAAS,KAAK,IAAI,MAAM,qBAAsB,QAAO,MAAM,KAAK,IAAI;AAC9H;AAEA,SAAS,qBAAqB;AAC5B,QAAM,IAAI,UAAU,iDAAiD;AACvE;AAEA,SAAS,eAAe,OAAO;AAC7B,MAAI;AAEJ,MAAI,OAAO,UAAU,YAAY;AAE/B,cAAU;MACR,UAAU;IAChB;EACA,OAAS;AAEL,cAAU;EACd;AAEE,SAAO;AACT;AACA,SAAS,SAAS,UAAU,OAAO;AACjC,MAAI,UAAU,UAAU,SAAS,KAAK,UAAU,CAAC,MAAM,SAAY,UAAU,CAAC,IAAI,CAAA;AAClF,MAAI;AACJ,MAAI;AACJ,MAAI;AAEJ,MAAI,YAAY,SAASC,WAAU,OAAO;AACxC,aAAS,OAAO,UAAU,QAAQ,OAAO,IAAI,MAAM,OAAO,IAAI,OAAO,IAAI,CAAC,GAAG,OAAO,GAAG,OAAO,MAAM,QAAQ;AAC1G,WAAK,OAAO,CAAC,IAAI,UAAU,IAAI;IACrC;AAEI,kBAAc;AACd,QAAI,WAAW,UAAU,UAAW;AACpC,QAAI,UAAU,QAAQ;AAEtB,QAAI,OAAO,YAAY,YAAY;AACjC,gBAAU,QAAQ,OAAO,SAAS;IACxC;AAEI,SAAK,CAAC,WAAW,UAAU,cAAc,SAAS;AAChD,eAAS,MAAM,QAAQ,CAAC,KAAK,EAAE,OAAO,mBAAmB,WAAW,CAAC,CAAC;IAC5E;AAEI,gBAAY;AACZ,iBAAa,OAAO;AACpB,cAAU,WAAW,WAAY;AAC/B,eAAS,MAAM,QAAQ,CAAC,KAAK,EAAE,OAAO,mBAAmB,WAAW,CAAC,CAAC;AACtE,gBAAU;IAChB,GAAO,KAAK;EACZ;AAEE,YAAU,SAAS,WAAY;AAC7B,iBAAa,OAAO;AACpB,cAAU;EACd;AAEE,SAAO;AACT;AACA,SAAS,UAAU,MAAM,MAAM;AAC7B,MAAI,SAAS,KAAM,QAAO;AAE1B,MAAIH,UAAQ,IAAI,MAAM,UAAU;AAE9B,aAAS,OAAO,MAAM;AACpB,UAAI,CAAC,UAAU,KAAK,GAAG,GAAG,KAAK,GAAG,CAAC,GAAG;AACpC,eAAO;MACf;IACA;AAEI,WAAO;EACX;AAEE,SAAO;AACT;AAEA,IAAI,kBAEJ,WAAY;AACV,WAASI,iBAAgB,IAAI,SAAS,OAAO;AAC3C,oBAAgB,MAAMA,gBAAe;AAErC,SAAK,KAAK;AACV,SAAK,WAAW;AAChB,SAAK,SAAS;AACd,SAAK,eAAe,SAAS,KAAK;EACtC;AAEE,eAAaA,kBAAiB,CAAC;IAC7B,KAAK;IACL,OAAO,SAAS,eAAe,SAAS;AACtC,UAAI,QAAQ;AAEZ,UAAI,KAAK,UAAU;AACjB,aAAK,gBAAe;MAC5B;AAEM,UAAI,KAAK,OAAQ;AACjB,WAAK,UAAU,eAAe,OAAO;AAErC,WAAK,WAAW,SAAU,QAAQ,OAAO;AACvC,cAAM,QAAQ,SAAS,QAAQ,KAAK;AAEpC,YAAI,UAAU,MAAM,QAAQ,MAAM;AAChC,gBAAM,SAAS;AAEf,gBAAM,gBAAe;QAC/B;MACA;AAGM,UAAI,KAAK,YAAY,KAAK,QAAQ,UAAU;AAC1C,YAAI,OAAO,KAAK,QAAQ,mBAAmB,CAAA,GACvC,WAAW,KAAK;AAEpB,aAAK,WAAW,SAAS,KAAK,UAAU,KAAK,QAAQ,UAAU;UAC7D,SAAS,SAAS,QAAQ,OAAO;AAC/B,mBAAO,aAAa,UAAU,aAAa,aAAa,SAAS,aAAa,YAAY,CAAC;UACvG;QACA,CAAS;MACT;AAEM,WAAK,YAAY;AACjB,WAAK,WAAW,IAAI,qBAAqB,SAAU,SAAS;AAC1D,YAAI,QAAQ,QAAQ,CAAC;AAErB,YAAI,QAAQ,SAAS,GAAG;AACtB,cAAI,oBAAoB,QAAQ,KAAK,SAAU,GAAG;AAChD,mBAAO,EAAE;UACrB,CAAW;AAED,cAAI,mBAAmB;AACrB,oBAAQ;UACpB;QACA;AAEQ,YAAI,MAAM,UAAU;AAElB,cAAI,SAAS,MAAM,kBAAkB,MAAM,qBAAqB,MAAM;AACtE,cAAI,WAAW,MAAM,UAAW;AAChC,gBAAM,YAAY;AAElB,gBAAM,SAAS,QAAQ,KAAK;QACtC;MACA,GAAS,KAAK,QAAQ,YAAY;AAE5B,iBAAW,WAAY;AACrB,YAAI,MAAM,UAAU;AAClB,gBAAM,SAAS,QAAQ,MAAM,EAAE;QACzC;MACA,CAAO;IACP;EACA,GAAK;IACD,KAAK;IACL,OAAO,SAAS,kBAAkB;AAChC,UAAI,KAAK,UAAU;AACjB,aAAK,SAAS,WAAU;AACxB,aAAK,WAAW;MACxB;AAGM,UAAI,KAAK,YAAY,KAAK,SAAS,QAAQ;AACzC,aAAK,SAAS,OAAM;AAEpB,aAAK,WAAW;MACxB;IACA;EACA,GAAK;IACD,KAAK;IACL,KAAK,SAAS,MAAM;AAClB,aAAO,KAAK,QAAQ,gBAAgB,KAAK,QAAQ,aAAa,aAAa;IACjF;EACA,CAAG,CAAC;AAEF,SAAOA;AACT,EAAC;AAED,SAAS,QAAQ,IAAI,OAAO,OAAO;AACjC,MAAI,QAAQ,MAAM;AAClB,MAAI,CAAC,MAAO;AAEZ,MAAI,OAAO,yBAAyB,aAAa;AAC/C,YAAQ,KAAK,oLAAoL;EACrM,OAAS;AACL,QAAI,QAAQ,IAAI,gBAAgB,IAAI,OAAO,KAAK;AAChD,OAAG,uBAAuB;EAC9B;AACA;AAEA,SAAS,UAAU,IAAI;AACrB,MAAI,QAAQ,GAAG;AAEf,MAAI,OAAO;AACT,UAAM,gBAAe;AACrB,WAAO,GAAG;EACd;AACA;AAEA,SAAS,iBAAiB,IAAI,OAAO,OAAO;AAC1C,MAAI,QAAQ,MAAM,OACd,WAAW,MAAM;AACrB,MAAI,UAAU,OAAO,QAAQ,EAAG;AAChC,MAAI,QAAQ,GAAG;AAEf,MAAI,CAAC,OAAO;AACV,cAAU,EAAE;AACZ;EACJ;AAEE,MAAI,OAAO;AACT,UAAM,eAAe,OAAO,KAAK;EACrC,OAAS;AACL,YAAQ,IAAI;MACV;IACN,GAAO,KAAK;EACZ;AACA;AAEA,IAAI,oBAAoB;EACtB;EACA;EACA;AACF;AChRO,IAAMF,QAAQ;EACnBG,OAAO;IACLC,MAAMC;IACNC,UAAU;EAFL;EAKPC,UAAU;IACRH,MAAMI;IACNC,SAAS;EAFD;EAKVC,WAAW;IACTN,MAAMI;IACNC,SAAS;IACTE,WAAW,SAAA,UAACC,OAAD;AAAA,aAAW,CAAC,YAAY,YAAb,EAA2BC,SAASD,KAApC;IAAX;EAHF;AAXQ;AAkBd,IAAME,eAAe,SAAAA,cAACC,MAAS;AACpC,MAAMC,QAAQ;AAEd,WAASC,QAASF,OAAMG,IAAI;AAC1B,QAAIH,MAAKI,eAAe,MAAM;AAAE,aAAOD;IAAK;AAC5C,WAAOD,QAAQF,MAAKI,YAAYD,GAAGE,OAAO,CAACL,KAAD,CAAV,CAAlB;EACf;AAED,WAASM,MAAON,OAAMO,MAAM;AAC1B,WAAOC,iBAAiBR,OAAM,IAAP,EAAaS,iBAAiBF,IAA9C;EACR;AAED,WAASG,SAAUV,OAAM;AACvB,WAAOM,MAAMN,OAAM,UAAP,IAAqBM,MAAMN,OAAM,YAAP,IAAuBM,MAAMN,OAAM,YAAP;EACnE;AAED,WAASW,OAAQX,OAAM;AACrB,WAAOC,MAAMW,KAAKF,SAASV,KAAD,CAAnB;EACR;AAED,WAASD,cAAcC,OAAM;AAC3B,QAAI,EAAEA,iBAAgBa,eAAeb,iBAAgBc,aAAa;AAChE;IACD;AAED,QAAMX,KAAKD,QAAQF,MAAKI,YAAY,CAAA,CAAlB;AAElB,aAASW,IAAI,GAAGA,IAAIZ,GAAGa,QAAQD,KAAK,GAAG;AACrC,UAAIJ,OAAOR,GAAGY,CAAD,CAAH,GAAS;AACjB,eAAOZ,GAAGY,CAAD;MACV;IACF;AAED,WAAOE,SAASC,oBAAoBD,SAASE;EAC9C;AAED,SAAOpB,cAAaC,IAAD;AACpB;AAEM,SAASoB,cAAe;AAC7B,SAAO,KAAKhC,MAAM4B,UAAU,QAAO,KAAK5B,MAAM,CAAX,CAAP,MAAyB;AACtD;AC3DM,IAAIiC,kBAAkB;AAE7B,IAAI,OAAOC,WAAW,aAAa;AACjCD,oBAAkB;AAClB,MAAI;AACEE,WAAOC,OAAOC,eAAe,CAAA,GAAI,WAAW;MAC9CC,KAD8C,SAAA,MACvC;AACLL,0BAAkB;MACnB;IAH6C,CAArC;AAKXC,WAAOK,iBAAiB,QAAQ,MAAMJ,IAAtC;EACD,SAAQK,GAAG;EAAA;AACb;AAPOL;AC0DR,IAAIM,MAAM;AAEV,IAAAC,UAAeC,gBAAgB;EAC7BC,MAAM;EAENC,YAAY;IACVC,gBAAAA;EADU;EAIZC,YAAY;IACVC;EADU;EAIZnD,OAAK,eAAA,CAAA,GACAA,OADA;IAGHoD,UAAU;MACRhD,MAAMiD;MACN5C,SAAS;IAFD;IAKV6C,aAAa;MACXlD,MAAM,CAACiD,QAAQ7C,MAAT;MACNC,SAAS;IAFE;IAKb8C,WAAW;MACTnD,MAAMI;MACNC,SAAS;IAFA;IAKX+C,WAAW;MACTpD,MAAMI;MACNC,SAAS;IAFA;IAKXgD,QAAQ;MACNrD,MAAMiD;MACN5C,SAAS;IAFH;IAKRiD,UAAU;MACRtD,MAAMuD;MACNlD,SAAS;IAFD;IAKVmD,WAAW;MACTxD,MAAMiD;MACN5C,SAAS;IAFA;IAKXoD,YAAY;MACVzD,MAAMuD;MACNlD,SAAS;IAFC;EAtCT,CAAA;EA4CLqD,OAAO,CAAC,WAAW,UAAU,UAAU,QAAhC;EAEPC,MAzD6B,SAAA,OAyDrB;AACN,WAAO;MACLC,MAAM,CAAA;MACNC,WAAW;MACXC,OAAO;MACPC,UAAU;IAJL;EAMR;EAEDC,UAAU;IACRC,OADQ,SAAA,QACC;AACP,UAAI,KAAKjB,aAAa,MAAM;AAC1B,YAAMiB,SAAQ;UACZ,MAAM;YAAEC,aAAa;UAAf;QADM;AAGd,YAAMnE,SAAQ,KAAKA;AACnB,YAAMoE,QAAQ,KAAKhB;AACnB,YAAMD,cAAc,KAAKA;AACzB,YAAIkB,kBAAkB;AACtB,YAAIF,cAAc;AAClB,YAAIG;AACJ,iBAAS3C,IAAI,GAAG4C,IAAIvE,OAAM4B,QAAQD,IAAI4C,GAAG5C,KAAK;AAC5C2C,oBAAUtE,OAAM2B,CAAD,EAAIyC,KAAT,KAAmBjB;AAC7B,cAAImB,UAAUD,iBAAiB;AAC7BA,8BAAkBC;;AAEpBH,yBAAeG;AACfJ,UAAAA,OAAMvC,CAAD,IAAM;YAAEwC;YAAaK,MAAMF;UAArB;;AAGb,aAAKG,wBAAwBJ;AAC7B,eAAOH;;AAET,aAAO,CAAA;IACR;IAEDlC;EA3BQ;EA8BV0C,OAAO;IACL1E,OADK,SAAA,QACI;AACP,WAAK2E,mBAAmB,IAAxB;IACD;IAEDpB,UALK,SAAA,WAKO;AACV,WAAKqB,cAAL;AACA,WAAKD,mBAAmB,KAAxB;IACD;IAEDT,OAAO;MACLW,SADK,SAAA,UACM;AACT,aAAKF,mBAAmB,KAAxB;MACD;MACDG,MAAM;IAJD;EAVF;EAkBPC,SAlH6B,SAAA,UAkHlB;AACT,SAAKC,eAAe;AACpB,SAAKC,aAAa;AAClB,SAAKC,UAAU,oBAAIC,IAAJ;AACf,SAAKC,gBAAgB,oBAAID,IAAJ;AACrB,SAAKE,gBAAgB;AACrB,SAAKC,6BAA6B;AAIlC,QAAI,KAAK7B,WAAW;AAClB,WAAK8B,cAAc;AACnB,WAAKZ,mBAAmB,KAAxB;;EAEH;EAEDa,SAlI6B,SAAAA,WAkIlB;AAAA,QAAA,QAAA;AACT,SAAKZ,cAAL;AACA,SAAKa,UAAU,WAAM;AAEnB,YAAKF,cAAc;AACnB,YAAKZ,mBAAmB,IAAxB;AACA,YAAKZ,QAAQ;IACd,CALD;EAMD;EAED2B,eA5I6B,SAAA,gBA4IZ;AACf,SAAKC,gBAAL;EACD;EAEDC,SAAS;IACPC,SADO,SAAA,QACEhC,MAAMiC,OAAOC,MAAMC,KAAK/F,MAAM;AACrC,UAAMgG,OAAO;QACXF;QACAG,UAAU;MAFC;AAIbD,WAAKE,KAAK;QACRC,IAAI3D;QACJqD;QACAO,MAAM;QACNL;QACA/F;MALQ;AAOV4D,WAAKyC,KAAKL,IAAV;AACA,aAAOA;IACR;IAEDM,WAjBO,SAAA,UAiBIN,MAAoB;AAAA,UAAdO,OAAc,UAAA,SAAA,KAAA,UAAA,CAAA,MAAA,SAAA,UAAA,CAAA,IAAP;AACtB,UAAMC,cAAc,KAAKrB;AACzB,UAAMnF,OAAOgG,KAAKE,GAAGlG;AACrB,UAAIyG,aAAaD,YAAYnE,IAAIrC,IAAhB;AACjB,UAAI,CAACyG,YAAY;AACfA,qBAAa,CAAA;AACbD,oBAAYE,IAAI1G,MAAMyG,UAAtB;;AAEFA,iBAAWJ,KAAKL,IAAhB;AACA,UAAI,CAACO,MAAM;AACTP,aAAKE,GAAGE,OAAO;AACfJ,aAAKC,WAAW;AAChB,aAAKhB,QAAQ0B,OAAOX,KAAKE,GAAGH,GAA5B;;IAEH;IAEDa,cAjCO,SAAA,eAiCS;AACd,WAAKC,MAAM,QAAX;AACA,UAAI,KAAK/C,MAAO,MAAKY,mBAAmB,KAAxB;IACjB;IAEDoC,cAtCO,SAAA,aAsCOC,OAAO;AAAA,UAAA,SAAA;AACnB,UAAI,CAAC,KAAK3B,eAAe;AACvB,aAAKA,gBAAgB;AACrB4B,8BAAsB,WAAM;AAC1B,iBAAK5B,gBAAgB;AADK,cAAA,wBAEH,OAAKV,mBAAmB,OAAO,IAA/B,GAAfuC,aAFkB,sBAElBA;AAIR,cAAI,CAACA,YAAY;AACfC,yBAAa,OAAKC,eAAN;AACZ,mBAAKA,kBAAkBC,WAAW,OAAKN,cAAc,GAApB;;QAEpC,CAVoB;;IAYxB;IAEDO,wBAvDO,SAAA,uBAuDiBC,WAAWC,OAAO;AAAA,UAAA,SAAA;AACxC,UAAI,KAAKzD,OAAO;AACd,YAAIwD,aAAaC,MAAMC,mBAAmBC,UAAU,KAAKF,MAAMC,mBAAmBE,WAAW,GAAG;AAC9F,eAAKb,MAAM,SAAX;AACAG,gCAAsB,WAAM;AAC1B,mBAAKtC,mBAAmB,KAAxB;UACD,CAFoB;eAGhB;AACL,eAAKmC,MAAM,QAAX;;;IAGL;IAEDnC,oBApEO,SAAA,mBAoEaiD,WAAsC;AAAA,UAA3BC,oBAA2B,UAAA,SAAA,KAAA,UAAA,CAAA,MAAA,SAAA,UAAA,CAAA,IAAP;AACjD,UAAM5E,WAAW,KAAKA;AACtB,UAAME,cAAc,KAAKsB;AACzB,UAAMpB,YAAY,KAAKA;AACvB,UAAMjD,WAAW,KAAK4B,cAAc,OAAO,KAAK5B;AAChD,UAAMJ,SAAQ,KAAKA;AACnB,UAAM8H,QAAQ9H,OAAM4B;AACpB,UAAMsC,SAAQ,KAAKA;AACnB,UAAM6D,QAAQ,KAAK7C;AACnB,UAAMuB,cAAc,KAAKrB;AACzB,UAAMvB,OAAO,KAAKA;AAClB,UAAImE,YAAYC;AAChB,UAAInE;AAEJ,UAAI,CAACgE,OAAO;AACVE,qBAAaC,WAAWnE,YAAY;iBAC3B,KAAKyB,aAAa;AAC3ByC,qBAAa;AACbC,mBAAW,KAAKxE;AAChBK,oBAAY;aACP;AACL,YAAMvC,SAAS,KAAK2G,UAAL;AAGf,YAAIL,mBAAmB;AACrB,cAAIM,eAAe5G,OAAO6G,QAAQ,KAAK9C;AACvC,cAAI6C,eAAe,EAAGA,gBAAe,CAACA;AACtC,cAAKlF,aAAa,QAAQkF,eAAehF,eAAgBgF,eAAelF,UAAU;AAChF,mBAAO;cACLiE,YAAY;YADP;;;AAKX,aAAK5B,6BAA6B/D,OAAO6G;AAEzC,YAAM9E,SAAS,KAAKA;AACpB/B,eAAO6G,SAAS9E;AAChB/B,eAAO8G,OAAO/E;AAGd,YAAIL,aAAa,MAAM;AACrB,cAAIqF;AACJ,cAAIC,IAAI;AACR,cAAIC,IAAIV,QAAQ;AAChB,cAAInG,IAAI,CAAC,EAAEmG,QAAQ;AACnB,cAAIW;AAGJ,aAAG;AACDA,mBAAO9G;AACP2G,gBAAIpE,OAAMvC,CAAD,EAAIwC;AACb,gBAAImE,IAAI/G,OAAO6G,OAAO;AACpBG,kBAAI5G;uBACKA,IAAImG,QAAQ,KAAK5D,OAAMvC,IAAI,CAAL,EAAQwC,cAAc5C,OAAO6G,OAAO;AACnEI,kBAAI7G;;AAENA,gBAAI,CAAC,GAAG4G,IAAIC,KAAK;mBACV7G,MAAM8G;AACf9G,cAAI,MAAMA,IAAI;AACdqG,uBAAarG;AAGbmC,sBAAYI,OAAM4D,QAAQ,CAAT,EAAY3D;AAG7B,eAAK8D,WAAWtG,GAAGsG,WAAWH,SAAS5D,OAAM+D,QAAD,EAAW9D,cAAc5C,OAAO8G,KAAKJ,YAAjF;UAAA;AACA,cAAIA,aAAa,IAAI;AACnBA,uBAAWjI,OAAM4B,SAAS;iBACrB;AACLqG;AAEAA,uBAAWH,UAAUG,WAAWH;;eAE7B;AAELE,uBAAa,CAAC,EAAEzG,OAAO6G,QAAQnF;AAC/BgF,qBAAWS,KAAKC,KAAKpH,OAAO8G,MAAMpF,QAAvB;AAGX+E,uBAAa,MAAMA,aAAa;AAChCC,qBAAWH,UAAUG,WAAWH;AAEhChE,sBAAYgE,QAAQ7E;;;AAIxB,UAAIgF,WAAWD,aAAaY,OAAOlJ,YAAY;AAC7C,aAAKmJ,gBAAL;;AAGF,WAAK/E,YAAYA;AAEjB,UAAImC;AAEJ,UAAMiB,aAAac,cAAc,KAAK/C,cAAcgD,YAAY,KAAKjD;AAErE,UAAI,KAAK8D,iBAAiB5B,YAAY;AACpC,YAAIA,YAAY;AACda,gBAAMgB,MAAN;AACAtC,sBAAYsC,MAAZ;AACA,mBAASpH,KAAI,GAAG4C,IAAIV,KAAKjC,QAAQD,KAAI4C,GAAG5C,MAAK;AAC3CsE,mBAAOpC,KAAKlC,EAAD;AACX,iBAAK4E,UAAUN,IAAf;;;AAGJ,aAAK6C,eAAe5B;iBACXA,YAAY;AACrB,iBAASvF,MAAI,GAAG4C,KAAIV,KAAKjC,QAAQD,MAAI4C,IAAG5C,OAAK;AAC3CsE,iBAAOpC,KAAKlC,GAAD;AACX,cAAIsE,KAAKE,GAAGE,MAAM;AAEhB,gBAAIuB,WAAW;AACb3B,mBAAKE,GAAGL,QAAQ9F,OAAMgJ,UACpB,SAAAjD,OAAAA;uBAAQ3F,WAAW2F,MAAK3F,QAAD,MAAe6F,KAAKF,KAAK3F,QAAV,IAAsB2F,UAASE,KAAKF;eAD5D;;AAMlB,gBACEE,KAAKE,GAAGL,UAAU,MAClBG,KAAKE,GAAGL,QAAQkC,cAChB/B,KAAKE,GAAGL,SAASmC,UACjB;AACA,mBAAK1B,UAAUN,IAAf;;;;;AAMR,UAAMgD,cAAc/B,aAAa,OAAO,oBAAI/B,IAAJ;AAExC,UAAIY,MAAM9F,MAAMyG;AAChB,UAAIwC;AACJ,eAASvH,MAAIqG,YAAYrG,MAAIsG,UAAUtG,OAAK;AAC1CoE,eAAO/F,OAAM2B,GAAD;AACZ,YAAMqE,MAAM5F,WAAW2F,KAAK3F,QAAD,IAAa2F;AACxC,YAAIC,OAAO,MAAM;AACf,gBAAM,IAAImD,MAAJ,UAAA,OAAoBnD,KAApB,yBAAA,EAAA,OAAiD5F,UAAjD,IAAA,CAAA;;AAER6F,eAAO8B,MAAMzF,IAAI0D,GAAV;AAEP,YAAI,CAAC/C,YAAY,CAACiB,OAAMvC,GAAD,EAAI6C,MAAM;AAC/B,cAAIyB,KAAM,MAAKM,UAAUN,IAAf;AACV;;AAIF,YAAI,CAACA,MAAM;AACThG,iBAAO8F,KAAK1C,SAAD;AACXqD,uBAAaD,YAAYnE,IAAIrC,IAAhB;AAEb,cAAIiH,YAAY;AAEd,gBAAIR,cAAcA,WAAW9E,QAAQ;AACnCqE,qBAAOS,WAAW0C,IAAX;AACPnD,mBAAKF,OAAOA;AACZE,mBAAKE,GAAGE,OAAO;AACfJ,mBAAKE,GAAGL,QAAQnE;AAChBsE,mBAAKE,GAAGH,MAAMA;AACdC,mBAAKE,GAAGlG,OAAOA;mBACV;AACLgG,qBAAO,KAAKJ,QAAQhC,MAAMlC,KAAGoE,MAAMC,KAAK/F,IAAjC;;iBAEJ;AAILiJ,gBAAID,YAAY3G,IAAIrC,IAAhB,KAAyB;AAE7B,gBAAI,CAACyG,cAAcwC,KAAKxC,WAAW9E,QAAQ;AACzCqE,qBAAO,KAAKJ,QAAQhC,MAAMlC,KAAGoE,MAAMC,KAAK/F,IAAjC;AACP,mBAAKsG,UAAUN,MAAM,IAArB;AACAS,2BAAaD,YAAYnE,IAAIrC,IAAhB;;AAGfgG,mBAAOS,WAAWwC,CAAD;AACjBjD,iBAAKF,OAAOA;AACZE,iBAAKE,GAAGE,OAAO;AACfJ,iBAAKE,GAAGL,QAAQnE;AAChBsE,iBAAKE,GAAGH,MAAMA;AACdC,iBAAKE,GAAGlG,OAAOA;AACfgJ,wBAAYtC,IAAI1G,MAAMiJ,IAAI,CAA1B;AACAA;;AAEFnB,gBAAMpB,IAAIX,KAAKC,IAAf;eACK;AACLA,eAAKE,GAAGE,OAAO;AACfJ,eAAKF,OAAOA;;AAId,YAAI9C,aAAa,MAAM;AACrBgD,eAAKC,WAAWhC,OAAMvC,MAAI,CAAL,EAAQwC;eACxB;AACL8B,eAAKC,WAAWvE,MAAIsB;;;AAIxB,WAAK+B,eAAegD;AACpB,WAAK/C,aAAagD;AAElB,UAAI,KAAKvE,WAAY,MAAKoD,MAAM,UAAUkB,YAAYC,QAAjC;AAIrBd,mBAAa,KAAKkC,WAAN;AACZ,WAAKA,cAAchC,WAAW,KAAKiC,WAAW,GAAjB;AAE7B,aAAO;QACLpC;MADK;IAGR;IAEDqC,mBAzRO,SAAA,oBAyRc;AACnB,UAAIC,SAAS7I,aAAa,KAAK8I,GAAN;AAEzB,UAAIvH,OAAOL,aAAa2H,WAAWtH,OAAOL,SAASE,mBAAmByH,WAAWtH,OAAOL,SAAS6H,OAAO;AACtGF,iBAAStH;;AAEX,aAAOsH;IACR;IAEDtB,WAlSO,SAAA,YAkSM;AAAA,UACEyB,KAAkB,KAAvBF,KAASlJ,aAAc,KAAdA;AACjB,UAAMqJ,aAAarJ,eAAc;AACjC,UAAIsJ;AAEJ,UAAI,KAAKtG,UAAU;AACjB,YAAMuG,SAASH,GAAGI,sBAAH;AACf,YAAMC,aAAaJ,aAAaE,OAAOnC,SAASmC,OAAOpC;AACvD,YAAIU,QAAQ,EAAEwB,aAAaE,OAAOG,MAAMH,OAAOI;AAC/C,YAAI1F,QAAOoF,aAAa1H,OAAOiI,cAAcjI,OAAOkI;AACpD,YAAIhC,QAAQ,GAAG;AACb5D,UAAAA,SAAQ4D;AACRA,kBAAQ;;AAEV,YAAIA,QAAQ5D,QAAOwF,YAAY;AAC7BxF,UAAAA,QAAOwF,aAAa5B;;AAEtByB,sBAAc;UACZzB;UACAC,KAAKD,QAAQ5D;QAFD;iBAILoF,YAAY;AACrBC,sBAAc;UACZzB,OAAOuB,GAAGU;UACVhC,KAAKsB,GAAGU,YAAYV,GAAGW;QAFX;aAIT;AACLT,sBAAc;UACZzB,OAAOuB,GAAGY;UACVlC,KAAKsB,GAAGY,aAAaZ,GAAGa;QAFZ;;AAMhB,aAAOX;IACR;IAEDjF,eAtUO,SAAA,gBAsUU;AACf,UAAI,KAAKrB,UAAU;AACjB,aAAKkH,aAAL;aACK;AACL,aAAK9E,gBAAL;;IAEH;IAED8E,cA9UO,SAAA,eA8US;AACd,WAAKC,iBAAiB,KAAKnB,kBAAL;AACtB,WAAKmB,eAAenI,iBAAiB,UAAU,KAAKwE,cAAc9E,kBAAkB;QAClF0I,SAAS;MADyE,IAEhF,KAFJ;AAGA,WAAKD,eAAenI,iBAAiB,UAAU,KAAKsE,YAApD;IACD;IAEDlB,iBAtVO,SAAA,kBAsVY;AACjB,UAAI,CAAC,KAAK+E,gBAAgB;AACxB;;AAGF,WAAKA,eAAeE,oBAAoB,UAAU,KAAK7D,YAAvD;AACA,WAAK2D,eAAeE,oBAAoB,UAAU,KAAK/D,YAAvD;AAEA,WAAK6D,iBAAiB;IACvB;IAEDG,cAjWO,SAAA,aAiWO/E,OAAO;AACnB,UAAIvE;AACJ,UAAI,KAAK0B,aAAa,MAAM;AAC1B1B,iBAASuE,QAAQ,IAAI,KAAK5B,MAAM4B,QAAQ,CAAnB,EAAsB3B,cAAc;aACpD;AACL5C,iBAASuE,QAAQ,KAAK7C;;AAExB,WAAK6H,iBAAiBvJ,MAAtB;IACD;IAEDuJ,kBA3WO,SAAA,iBA2WW5E,UAAU;AAC1B,UAAI,KAAK3F,cAAc,YAAY;AACjC,aAAKkJ,IAAIY,YAAYnE;aAChB;AACL,aAAKuD,IAAIc,aAAarE;;IAEzB;IAED2C,iBAnXO,SAAA,kBAmXY;AAAA,UAAA,SAAA;AACjBxB,iBAAW,WAAM;AACf0D,gBAAQC,IAAI,+FAAgG,aAAa,OAAKvB,GAA9H;AACAsB,gBAAQC,IAAI,4LAAZ;MACD,CAHS;AAIV,YAAM,IAAI7B,MAAM,8BAAV;IACP;IAEDG,WA3XO,SAAA,YA2XM;AACX,WAAKzF,KAAKoH,KAAK,SAACC,OAAOC,OAAR;AAAA,eAAkBD,MAAM/E,GAAGL,QAAQqF,MAAMhF,GAAGL;MAA5C,CAAf;IACD;EA7XM;AAhJoB,CAAD;;;ECpDxBsF,OAAM;;;;EA+BNA,OAAM;;;;;sCA3CVC;IAAAA;IAAAA;MAEED,OAAK,CAAC,wBAAA,gBAAA;;;;;eAMWE,KAAAA,aAAA,MAAAA,MAAAA,SAAAA;;;KAGTA,KAAAA,OAAOC,UAAAA,UAAAA,GADfF,YAAAA,OAAAG,aAAAA,CAIEC,WAAAA,KAAAA,QAAAA,QAAAA,CAAAA,CAAAA,KAAAA,mBAAAA,QAAAA,IAAAA,GAKFC;MAAAA;MAAAA;QACEC,KAAI;QACHzK,OAAK,gBAAA,CAAA,GAAKoK,KAAAA,cAAA,aAAA,cAAA,YAAsDA,KAAAA,YAAA,IAA3D;QACNF,OAAM;;yBAENC;QAAAA;QAAAA;QAAAA,WACiBC,KAAAA,MAAAA,SAARrF,MAAAA;8BADToF;YAAAA;YAAAA;cAEGrF,KAAKC,KAAKE,GAAGC;cACblF,OAAOoK,KAAAA,QAAA;8CAAiCA,KAAAA,cAAA,aAAA,MAAA,KAAA,GAAA,EAAA,OAAwCrF,KAAKC,UAAAA,KAAAA;kBAA9E;cACRkF,OAAK,CAAC,mCAAA;uBACWE,KAAAA,aAAarF,KAAKE,GAAGH;;cACrC4F,cAAU,SAAA,aAAA,QAAA;uBAAEN,KAAAA,WAAWrF,KAAKE,GAAGH;;cAC/B6F,cAAU,OAAA,CAAA,MAAA,OAAA,CAAA,IAAA,SAAA,QAAA;uBAAEP,KAAAA,WAAA;;;aAEbG,WAAAA,KAAAA,QAAAA,WAAAA;cACG1F,MAAME,KAAKF;cACXD,OAAOG,KAAKE,GAAGL;cACfgG,QAAQ7F,KAAKE,GAAGE;;;;;;;;;;;OAMfiF,KAAAA,OAAOS,SAAAA,UAAAA,GADfV,YAAAA,OAAAW,YAAAA,CAIEP,WAAAA,KAAAA,QAAAA,OAAAA,CAAAA,CAAAA,KAAAA,mBAAAA,QAAAA,IAAAA,GAKFC;MAAAA;MAAAA;QAAiBO,UAAQX,KAAAA;;;;;;;;uCAjDHA,KAAAA,sBAAAA,CAAAA,CAAAA;;;;ACiC1B,IAAA,WAAe;EACb1I,MAAM;EAENC,YAAY;IACVqJ,iBAAAA;EADU;EAIZC,SAPa,SAAA,UAOF;AAAA,QAAA,QAAA;AACT,QAAIC,wBAAwBC;AAE5B,QAAI,OAAOvJ,mBAAmB,aAAa;AACzCsJ,8BAAwB,IAAItJ,eAAe,SAAAwJ,SAAW;AAAA,YAAA,YAAA,2BAChCA,OADgC,GAAA;AAAA,YAAA;AACpD,eAAA,UAAA,EAAA,GAAA,EAAA,QAAA,UAAA,EAAA,GAAA,QAA6B;AAAA,gBAAlB9E,QAAkB,MAAA;AAC3B,gBAAIA,MAAMgC,QAAQ;AAChB,kBAAMxC,QAAQ,IAAIuF,YAAY,UAAU;gBACpCC,QAAQ;kBACNC,aAAajF,MAAMiF;gBADb;cAD4B,CAA1B;AAMdjF,oBAAMgC,OAAOkD,cAAc1F,KAA3B;;;QATgD,SAAA,KAAA;AAAA,oBAAA,EAAA,GAAA;QAAA,UAAA;AAAA,oBAAA,EAAA;QAAA;MAYrD,CAZuB;;AAe1B,WAAO;MACL2F,aAAa,KAAKA;MAClBC,eAAe;MACfR;MACAS,gBAAgB,SAAA,eAACC,IAAD;AAAA,eAAQ,MAAKC,WAAWzG,KAAKwG,EAArB;MAAR;IAJX;EAMR;EAEDE,cAAc;EAEdnN,OAAK,eAAA,CAAA,GACAA,OADA;IAGHsD,aAAa;MACXlD,MAAM,CAACiD,QAAQ7C,MAAT;MACNF,UAAU;IAFC;EAHV,CAAA;EASLwD,OAAO,CAAC,kBAAkB,UAAU,SAA7B;EAEPC,MA/Ca,SAAAA,QA+CL;AACN,WAAO;MACL+I,aAAa;QACXb,QAAQ;QACR5H,OAAO,CAAA;QACP+I,YAAY,CAAA;QACZ7M,UAAU,KAAKA;QACf4B,aAAa;MALF;MAOb+K,YAAY,CAAA;IARP;EAUR;EAED9I,UAAU;IACRjC;IAEAkL,eAHQ,SAAA,gBAGS;AACf,UAAMC,SAAS,CAAA;AADA,UAEPnN,SAAiC,KAAjCA,OAAOI,WAA0B,KAA1BA,UAAU4B,eAAgB,KAAhBA;AACzB,UAAMkC,SAAQ,KAAKyI,YAAYzI;AAC/B,eAASvC,IAAI,GAAGA,IAAI3B,OAAM4B,QAAQD,KAAK;AACrC,YAAMoE,OAAO/F,OAAM2B,CAAD;AAClB,YAAMyE,MAAKpE,eAAcL,IAAIoE,KAAK3F,QAAD;AACjC,YAAIoE,QAAON,OAAMkC,GAAD;AAChB,YAAI,OAAO5B,UAAS,eAAe,CAAC,KAAK4I,eAAehH,GAApB,GAAyB;AAC3D5B,UAAAA,QAAO;;AAET2I,eAAO7G,KAAK;UACVP;UACAK,IAAAA;UACA5B,MAAAA;QAHU,CAAZ;;AAMF,aAAO2I;IACR;IAEDE,WAvBQ,SAAA,YAuBK;AACX,UAAMA,aAAY,CAAA;AAElB,eAAWrH,OAAO,KAAKsH,QAAQ;AAC7B,YAAItH,IAAIuH,WAAW,IAAf,GAAsB;AACxB,cAAIvH,QAAQ,cAAcA,QAAQ,aAAa;AAC7CqH,YAAAA,WAAUrH,GAAD,IAAQ,KAAKsH;;;;AAK5B,aAAOD;IACR;EAnCO;EAsCV3I,OAAO;IACL1E,OADK,SAAAA,SACI;AACP,WAAKwN,YAAY,KAAjB;IACD;IAEDxL,aAAa;MACX6C,SADW,SAAAA,SACFpE,OAAO;AACd,aAAKkM,YAAY3K,cAAcvB;MAChC;MACDgN,WAAW;IAJA;IAOblN,WAZK,SAAA,UAYME,OAAO;AAChB,WAAK+M,YAAY,IAAjB;IACD;EAdI;EAiBPzI,SAnHa,SAAAA,WAmHF;AACT,SAAK2I,YAAY,CAAA;AACjB,SAAKC,mBAAmB;AACxB,SAAKP,iBAAiB,CAAA;EACvB;EAEDQ,WAzHa,SAAA,YAyHA;AACX,SAAKjB,YAAYb,SAAS;EAC3B;EAED+B,aA7Ha,SAAA,cA6HE;AACb,SAAKlB,YAAYb,SAAS;EAC3B;EAEDlG,SAAS;IACPkI,kBADO,SAAA,mBACa;AAClB,UAAMC,WAAW,KAAKC,MAAMD;AAC5B,UAAIA,UAAU;AACZ,aAAKP,YAAL;;AAEF,WAAK1G,MAAM,QAAX;IACD;IAEDmH,mBATO,SAAA,oBASc;AACnB,WAAKC,cAAc,KAAnB;AACA,WAAKpH,MAAM,SAAX;IACD;IAEDoH,eAdO,SAAA,gBAcsB;AAAA,UAAfC,QAAe,UAAA,SAAA,KAAA,UAAA,CAAA,MAAA,SAAA,UAAA,CAAA,IAAP;AACpB,UAAMvK,QAAO;QAAEuK;MAAF;AACb,WAAKrH,MAAM,kBAAkBlD,KAA7B;AAEA,WAAKmJ,WAAWqB,QAAQ,SAAAC,UAAAA;eAAYA,SAASzK,KAAD;OAA5C;IACD;IAED4J,aArBO,SAAA,cAqBoB;AAAA,UAAdzE,QAAc,UAAA,SAAA,KAAA,UAAA,CAAA,MAAA,SAAA,UAAA,CAAA,IAAN;AACnB,UAAIA,SAAS,KAAK/G,aAAa;AAC7B,aAAK2K,YAAYM,aAAa,CAAA;;AAEhC,WAAKiB,cAAc,IAAnB;IACD;IAEDrD,cA5BO,SAAAA,cA4BO/E,OAAO;AACnB,UAAMiI,WAAW,KAAKC,MAAMD;AAC5B,UAAIA,SAAUA,UAASlD,aAAa/E,KAAtB;IACf;IAEDwI,aAjCO,SAAA,YAiCMvI,MAAyB;AAAA,UAAnBD,QAAmB,UAAA,SAAA,KAAA,UAAA,CAAA,MAAA,SAAA,UAAA,CAAA,IAAXuG;AACzB,UAAMjG,MAAK,KAAKpE,cAAe8D,SAAS,OAAOA,QAAQ,KAAK9F,MAAMuO,QAAQxI,IAAnB,IAA4BA,KAAK,KAAK3F,QAAN;AACvF,aAAO,KAAKuM,YAAYzI,MAAMkC,GAAvB,KAA8B;IACtC;IAEDoI,gBAtCO,SAAA,iBAsCW;AAAA,UAAA,SAAA;AAChB,UAAI,KAAKC,oBAAqB;AAC9B,WAAKA,sBAAsB;AAC3B,UAAM9E,KAAK,KAAKF;AAEhB,WAAKhE,UAAU,WAAM;AACnBkE,WAAGU,YAAYV,GAAG+E,eAAe;AAEjC,YAAM5B,KAAK,SAALA,MAAW;AACfnD,aAAGU,YAAYV,GAAG+E,eAAe;AACjCzH,gCAAsB,WAAM;AAC1B0C,eAAGU,YAAYV,GAAG+E,eAAe;AACjC,gBAAI,OAAKf,qBAAqB,GAAG;AAC/B,qBAAKc,sBAAsB;mBACtB;AACLxH,oCAAsB6F,GAAD;;UAExB,CAPoB;;AASvB7F,8BAAsB6F,EAAD;MACtB,CAfD;IAgBD;EA3DM;AAjII;;;sBClCbzB;IAAAA;IAAAsD,WAAAA;MACEhD,KAAI;MACH3L,OAAO4O,SAAAA;MACP,iBAAeC,OAAAA;MACftO,WAAW+K,KAAAA;MACZ,aAAU;OACFA,KAAAA,QAAAA;MACPwD,UAAQF,SAAAA;MACRG,WAASH,SAAAA;OACVI,WAAMJ,SAAAA,SAAAA,CAAAA;IAAAA;MAEKtO,SAAO,QAChB,SAAA,MAAA;AAAA,YAD0B2O,eAC1B,KAAA,MADwCnJ,QACxC,KADwCA,OAAOgG,SAC/C,KAD+CA;AAC/C,eAAA,CAAAL,WAAAA,KAAAA,QAAAA,WAAAA;;;;;;MAAA,CAAA;MASSF,QAAM,QACf,WAAA;AAAA,eAAA,CAAAE,WAAAA,KAAAA,QAAAA,QAAAA,CAAAA;MAAA,CAAA;MAESM,OAAK,QACd,WAAA;AAAA,eAAA,CAAAN,WAAAA,KAAAA,QAAAA,OAAAA,CAAAA;MAAA,CAAA;;;;;;;;;ACxBN,IAAA,sBAAe;EACb7I,MAAM;EAENsM,QAAQ,CACN,eACA,iBACA,kBACA,uBAJM;EAORrP,OAAO;IACLkG,MAAM;MACJ5F,UAAU;IADN;IAINgP,WAAW;MACTlP,MAAMuD;MACNlD,SAAS;IAFA;;;;IAQXwL,QAAQ;MACN7L,MAAMuD;MACNrD,UAAU;IAFJ;IAKR2F,OAAO;MACL7F,MAAMiD;MACN5C,SAAS+L;IAFJ;IAKP+C,kBAAkB;MAChBnP,MAAM,CAACC,OAAOkC,MAAR;MACN9B,SAAS;IAFO;IAKlB+O,YAAY;MACVpP,MAAMuD;MACNlD,SAAS;IAFC;IAKZgP,KAAK;MACHrP,MAAMI;MACNC,SAAS;IAFN;EAjCA;EAuCP2D,UAAU;IACRmC,IADQ,SAAA,KACF;AACJ,aAAO,KAAKuG,YAAY3K,cAAc,KAAK8D,QAAQ,KAAKC,KAAK,KAAK4G,YAAYvM,QAA3B;IACpD;IAEDoE,MALQ,SAAA,OAKA;AACN,aAAQ,KAAKmI,YAAYM,WAAW,KAAK7G,EAAjC,KAAwC,KAAKuG,YAAYzI,MAAM,KAAKkC,EAA5B,KAAoC;IACrF;IAEDmJ,aATQ,SAAA,cASO;AACb,aAAO,KAAKzD,UAAU,KAAKa,YAAYb;IACxC;EAXO;EAcVpH,OAAO;IACLyK,WAAW;IAEX/I,IAHK,SAAAA,MAGC;AACJ,UAAI,CAAC,KAAK5B,MAAM;AACd,aAAKgL,aAAL;MACD;IACF;IAEDD,aATK,SAAAA,aASQ9O,OAAO;AAClB,UAAI,CAAC,KAAK+D,MAAM;AACd,YAAI/D,OAAO;AACT,cAAI,CAAC,KAAKmM,cAAcQ,eAAe,KAAKhH,EAAvC,GAA4C;AAC/C,iBAAKwG,cAAce;AACnB,iBAAKf,cAAcQ,eAAe,KAAKhH,EAAvC,IAA6C;UAC9C;QACF,OAAM;AACL,cAAI,KAAKwG,cAAcQ,eAAe,KAAKhH,EAAvC,GAA4C;AAC9C,iBAAKwG,cAAce;AACnB,iBAAKf,cAAcQ,eAAe,KAAKhH,EAAvC,IAA6C;UAC9C;QACF;MACF;AAED,UAAI,KAAKgG,uBAAuB;AAC9B,YAAI3L,OAAO;AACT,eAAKgP,YAAL;QACD,OAAM;AACL,eAAKC,cAAL;QACD;MACF,WAAUjP,SAAS,KAAKkP,2BAA2B,KAAKvJ,IAAI;AAC3D,aAAKwJ,WAAL;MACD;IACF;EAjCI;EAoCP7K,SAnGa,SAAAA,WAmGF;AAAA,QAAA,QAAA;AACT,QAAI,KAAK8K,UAAW;AAEpB,SAAKC,2BAA2B;AAChC,SAAKC,gBAAL;AAEA,QAAI,CAAC,KAAK3D,uBAAuB;AAAA,UAAA,QAAA,SAAA4D,OACpBC,IADoB;AAE7B,cAAKC,OAAO,WAAA;AAAA,iBAAM,MAAKd,iBAAiBa,EAAtB;QAAN,GAAgC,MAAKT,YAAjD;MAF6B;AAC/B,eAAWS,KAAK,KAAKb,kBAAkB;AAAA,cAA5Ba,CAA4B;MAEtC;AAED,WAAKpD,eAAe,kBAAkB,KAAKsD,eAA3C;IACD;EACF;EAED3K,SAlHa,SAAAA,WAkHF;AACT,QAAI,KAAKmH,YAAYb,QAAQ;AAC3B,WAAK8D,WAAL;AACA,WAAKH,YAAL;IACD;EACF;EAED/J,eAzHa,SAAAA,iBAyHI;AACf,SAAKgK,cAAL;EACD;EAED9J,SAAS;IACPgK,YADO,SAAA,aACO;AACZ,UAAI,KAAKL,aAAa;AACpB,YAAI,KAAKa,wBAAwB,KAAKhK,IAAI;AACxC,eAAKgK,sBAAsB,KAAKhK;AAChC,eAAK0J,2BAA2B;AAChC,eAAKH,yBAAyB;AAC9B,eAAKU,YAAY,KAAKjK,EAAtB;QACD;MACF,OAAM;AACL,aAAK0J,2BAA2B,KAAK1J;MACtC;IACF;IAED2J,iBAdO,SAAA,kBAcY;AAAA,UAAA,SAAA;AACjB,UAAI,KAAKZ,WAAW;AAClB,aAAKmB,cAAc,KAAKJ,OAAO,QAAQ,WAAM;AAC3C,iBAAKV,aAAL;QACD,GAAE;UACD1K,MAAM;QADL,CAFgB;MAKpB,WAAU,KAAKwL,aAAa;AAC3B,aAAKA,YAAL;AACA,aAAKA,cAAc;MACpB;IACF;IAEDH,iBA3BO,SAAA,gBAAA,MA2BqB;AAAA,UAAThC,QAAS,KAATA;AAEjB,UAAI,CAAC,KAAKoB,eAAepB,OAAO;AAC9B,aAAKwB,yBAAyB,KAAKvJ;MACpC;AAED,UAAI,KAAK0J,6BAA6B,KAAK1J,MAAM+H,SAAS,CAAC,KAAK3J,MAAM;AACpE,aAAKoL,WAAL;MACD;IACF;IAEDJ,cAtCO,SAAA,eAsCS;AACd,WAAKI,WAAL;IACD;IAEDS,aA1CO,SAAA,YA0CMjK,KAAI;AAAA,UAAA,SAAA;AACfmK,eAAS,WAAM;AACb,YAAI,OAAKnK,OAAOA,KAAI;AAClB,cAAMsB,QAAQ,OAAK+B,IAAI+G;AACvB,cAAM7I,SAAS,OAAK8B,IAAIgH;AACxB,iBAAKC,UAAUhJ,OAAOC,MAAtB;QACD;AACD,eAAKyI,sBAAsB;MAC5B,CAPO,EAOLO,KAPH;IAQD;IAEDD,WArDO,SAAA,UAqDIhJ,OAAOC,QAAQ;AACxB,UAAMnD,QAAOkE,KAAKkI,MAAM,KAAKhE,cAAcrM,cAAc,aAAaoH,SAASD,KAAlE;AACb,UAAIlD,SAAQ,KAAKA,SAASA,OAAM;AAC9B,YAAI,KAAKoI,cAAcQ,eAAe,KAAKhH,EAAvC,GAA4C;AAC9C,eAAKwG,cAAce;AACnB,eAAKf,cAAcQ,eAAe,KAAKhH,EAAvC,IAA6CiG;QAC9C;AACD,aAAKM,YAAYzI,MAAM,KAAKkC,EAA5B,IAAkC5B;AAClC,aAAKmI,YAAYM,WAAW,KAAK7G,EAAjC,IAAuC;AACvC,YAAI,KAAKiJ,WAAY,MAAKvI,MAAM,UAAU,KAAKV,EAA1B;MACtB;IACF;IAEDqJ,aAlEO,SAAA,cAkEQ;AACb,UAAI,CAAC,KAAKrD,sBAAuB;AACjC,WAAKA,sBAAsByE,QAAQ,KAAKpH,IAAIzI,UAA5C;AACA,WAAKyI,IAAIzI,WAAWuB,iBAAiB,UAAU,KAAKuM,QAApD;IACD;IAEDY,eAxEO,SAAA,gBAwEU;AACf,UAAI,CAAC,KAAKtD,sBAAuB;AACjC,WAAKA,sBAAsB0E,UAAU,KAAKrH,IAAIzI,UAA9C;AACA,WAAKyI,IAAIzI,WAAW4J,oBAAoB,UAAU,KAAKkE,QAAvD;IACD;IAEDA,UA9EO,SAAA,SA8EG9H,OAAO;AAAA,UAAA,wBACWA,MAAMwF,OAAOC,aAA/B/E,QADO,sBACPA,OAAOC,SADA,sBACAA;AACf,WAAK+I,UAAUhJ,OAAOC,MAAtB;IACD;EAjFM;EAoFToJ,QAjNa,SAAAA,UAiNH;AACR,WAAOC,YAAY,KAAK1B,KAAK,MAAM,KAAK2B,OAAO3Q,QAAZ,CAAjB;EACnB;AAnNY;;ACWf,SAAS4Q,mBAAoBC,KAAKC,QAAQ;AACxCD,MAAIE,UAAJ,GAAA,OAAiBD,QAAjB,kBAAA,GAA2ClF,OAA3C;AACAiF,MAAIE,UAAJ,GAAA,OAAiBD,QAAjB,iBAAA,GAA0ClF,OAA1C;AACAiF,MAAIE,UAAJ,GAAA,OAAiBD,QAAjB,kBAAA,GAA2CE,QAA3C;AACAH,MAAIE,UAAJ,GAAA,OAAiBD,QAAjB,iBAAA,GAA0CE,QAA1C;AACAH,MAAIE,UAAJ,GAAA,OAAiBD,QAAjB,uBAAA,GAAgDG,mBAAhD;AACAJ,MAAIE,UAAJ,GAAA,OAAiBD,QAAjB,qBAAA,GAA8CG,mBAA9C;AACD;AAED,IAAMC,SAAS;EACbC;EACAC,SAFa,SAAA,QAEJP,KAAKQ,SAAS;AACrB,QAAMC,eAAexP,OAAOyP,OAAO,CAAA,GAAI;MACrCC,mBAAmB;MACnBC,kBAAkB;IAFmB,GAGpCJ,OAHkB;AAKrB,aAAW3L,OAAO4L,cAAc;AAC9B,UAAI,OAAOA,aAAa5L,GAAD,MAAU,aAAa;AAC5C4C,eAAO5C,GAAD,IAAQ4L,aAAa5L,GAAD;MAC3B;IACF;AAED,QAAI4L,aAAaE,mBAAmB;AAClCZ,yBAAmBC,KAAKS,aAAaG,gBAAnB;IACnB;EACF;AAjBY;;",
  "names": ["getInternetExplorerVersion", "ua", "window", "navigator", "userAgent", "msie", "indexOf", "parseInt", "substring", "trident", "rv", "edge", "isIE", "initCompat", "init", "name", "props", "showTrigger", "type", "Boolean", "default", "emits", "setup", "emit", "_w", "_h", "elRef", "ref", "_resizeObject", "compareAndNotify", "value", "offsetWidth", "offsetHeight", "width", "height", "addResizeHandlers", "contentDocument", "defaultView", "addEventListener", "removeResizeHandlers", "onload", "removeEventListener", "removeChild", "onMounted", "object", "document", "createElement", "setAttribute", "appendChild", "data", "onBeforeUnmount", "class", "tabindex", "_createBlock", "_hoisted_1", "ResizeObserver", "install", "app", "component", "itemsLimit", "_typeof", "obj", "props", "throttled", "VisibilityState", "items", "type", "Array", "required", "keyField", "String", "default", "direction", "validator", "value", "includes", "scrollParent", "node", "regex", "parents", "ps", "parentNode", "concat", "style", "prop", "getComputedStyle", "getPropertyValue", "overflow", "scroll", "test", "HTMLElement", "SVGElement", "i", "length", "document", "scrollingElement", "documentElement", "simpleArray", "supportsPassive", "window", "opts", "Object", "defineProperty", "get", "addEventListener", "e", "uid", "script", "defineComponent", "name", "components", "ResizeObserver", "directives", "ObserveVisibility", "itemSize", "Number", "minItemSize", "sizeField", "typeField", "buffer", "pageMode", "Boolean", "prerender", "emitUpdate", "emits", "data", "pool", "totalSize", "ready", "hoverKey", "computed", "sizes", "accumulator", "field", "computedMinSize", "current", "l", "size", "$_computedMinItemSize", "watch", "updateVisibleItems", "applyPageMode", "handler", "deep", "created", "$_startIndex", "$_endIndex", "$_views", "Map", "$_unusedViews", "$_scrollDirty", "$_lastUpdateScrollPosition", "$_prerender", "mounted", "$nextTick", "beforeUnmount", "removeListeners", "methods", "addView", "index", "item", "key", "view", "position", "nr", "id", "used", "push", "unuseView", "fake", "unusedViews", "unusedPool", "set", "delete", "handleResize", "$emit", "handleScroll", "event", "requestAnimationFrame", "continuous", "clearTimeout", "$_refreshTimout", "setTimeout", "handleVisibilityChange", "isVisible", "entry", "boundingClientRect", "width", "height", "checkItem", "checkPositionDiff", "count", "views", "startIndex", "endIndex", "getScroll", "positionDiff", "start", "end", "h", "a", "b", "oldI", "Math", "ceil", "config", "itemsLimitError", "$_continuous", "clear", "findIndex", "unusedIndex", "v", "Error", "pop", "$_sortTimer", "sortViews", "getListenerTarget", "target", "$el", "body", "el", "isVertical", "scrollState", "bounds", "getBoundingClientRect", "boundsSize", "top", "left", "innerHeight", "innerWidth", "scrollTop", "clientHeight", "scrollLeft", "clientWidth", "addListeners", "listenerTarget", "passive", "removeEventListener", "scrollToItem", "scrollToPosition", "console", "log", "sort", "viewA", "viewB", "class", "_createBlock", "_ctx", "before", "_hoisted_1", "_renderSlot", "_createVNode", "ref", "onMouseenter", "onMouseleave", "active", "after", "_hoisted_2", "onNotify", "RecycleScroller", "provide", "vscrollResizeObserver", "undefined", "entries", "CustomEvent", "detail", "contentRect", "dispatchEvent", "vscrollData", "vscrollParent", "onUpdateScroll", "cb", "vScrollMap", "inheritAttrs", "validSizes", "itemsWithSize", "result", "$_undefinedMap", "listeners", "$attrs", "startsWith", "forceUpdate", "immediate", "$_updates", "$_undefinedSizes", "activated", "deactivated", "onScrollerResize", "scroller", "$refs", "onScrollerVisible", "vScrollUpdate", "force", "forEach", "callback", "getItemSize", "indexOf", "scrollToBottom", "$_scrollingToBottom", "scrollHeight", "_mergeProps", "$options", "$props", "onResize", "onVisible", "_toHandlers", "itemWithSize", "inject", "watchData", "sizeDependencies", "emitResize", "tag", "finalActive", "onDataUpdate", "observeSize", "unobserveSize", "$_pendingVScrollUpdate", "updateSize", "$isServer", "$_forceNextVScrollUpdate", "updateWatchData", "_loop", "k", "$watch", "onVscrollUpdate", "$_pendingSizeUpdate", "computeSize", "$_watchData", "nextTick", "offsetWidth", "offsetHeight", "applySize", "then", "round", "observe", "unobserve", "render", "createVNode", "$slots", "registerComponents", "app", "prefix", "component", "DynamicScroller", "DynamicScrollerItem", "plugin", "version", "install", "options", "finalOptions", "assign", "installComponents", "componentsPrefix"]
}
